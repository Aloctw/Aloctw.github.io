{"meta":{"title":"Aloctw","subtitle":"の陈十二吖","description":"十二加油站！","author":"Aloctw","url":"https://aloctw.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-07-02T06:55:04.000Z","updated":"2022-07-02T06:58:53.420Z","comments":false,"path":"about/index.html","permalink":"https://aloctw.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-07-20T11:07:20.000Z","updated":"2022-07-20T11:07:20.711Z","comments":false,"path":"archives/index.html","permalink":"https://aloctw.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-02T06:54:16.000Z","updated":"2022-07-02T06:57:21.324Z","comments":false,"path":"categories/index.html","permalink":"https://aloctw.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-03T09:06:16.000Z","updated":"2022-07-03T09:06:47.116Z","comments":false,"path":"contact/index.html","permalink":"https://aloctw.github.io/contact/index.html","excerpt":"","text":""},{"title":"友情连接","date":"2022-07-02T06:59:17.000Z","updated":"2022-07-02T06:59:48.863Z","comments":false,"path":"friends/index.html","permalink":"https://aloctw.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-02T08:43:25.000Z","updated":"2022-07-02T08:44:06.351Z","comments":false,"path":"guestbook/index.html","permalink":"https://aloctw.github.io/guestbook/index.html","excerpt":"","text":"# 欢迎来到我的博客！ > 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度，在nickname栏目输入QQ号可以直接获取你的QQ头像。"},{"title":"link","date":"2022-07-20T11:08:45.000Z","updated":"2022-07-20T11:08:45.900Z","comments":false,"path":"link/index.html","permalink":"https://aloctw.github.io/link/index.html","excerpt":"","text":""},{"title":"movies","date":"2022-07-20T11:08:29.000Z","updated":"2022-07-20T11:08:29.486Z","comments":false,"path":"movies/index.html","permalink":"https://aloctw.github.io/movies/index.html","excerpt":"","text":""},{"title":"music","date":"2022-07-20T11:08:14.000Z","updated":"2022-07-20T11:08:14.587Z","comments":false,"path":"music/index.html","permalink":"https://aloctw.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-02T06:54:40.000Z","updated":"2022-07-02T06:58:12.012Z","comments":false,"path":"tags/index.html","permalink":"https://aloctw.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Bean的生命周期和循环依赖","slug":"Bean的生命周期和循环依赖","date":"2022-04-16T08:25:52.000Z","updated":"2022-07-19T03:48:26.000Z","comments":true,"path":"2022/04/16/Bean的生命周期和循环依赖/","link":"","permalink":"https://aloctw.github.io/2022/04/16/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/","excerpt":"","text":"SpringBean的生命周期与循环依赖&amp;emsp;&amp;emsp;————–具体 Spring 源码等有时间了再贴上来，请见谅！————– &amp;emsp;&amp;emsp;Bean的生命周期主要有四个阶段：1.实例化–&gt; 2.属性填充–&gt; 3.初始化Bean –&gt; 4.销毁Bean** 1.实例化Bean 当用户端请求一个尚未初始化的 bean 时，或者初始化 bean 的时候需要注入另一个依赖的 bean Spring 容器启动进行扫描,把BeanName转换成BeanDefinition对象,放入BeanDefinitionMap 遍历做一系列的验证(是否单例、是否延迟加载、是否抽象) 去单例池中查是否存在,去二级缓存查是否存在,如果都没有,准备创建Bean 推断构造方法，通过反射实例化Java对象 2.属性填充 Bean实例创建出来后，接着就是给这个Bean对象进行属性填充，也就是注入这个Bean依赖的其它Bean对象。 如果支持循环依赖,生成当前Java对象的ObjectFactory对象存到二级缓存中,进行属性填充(自动注入)。 &amp;emsp;&amp;emsp;注意：默认支持解决 set 方式的循环依赖，而构造方法注入 Bean 依赖产生的循环依赖不能解决，因为构造方式注入会先加载属性依赖，而这个时候依赖的 bean 还没有创建。 3.初始化bean 调用实现的Aware接口的方法，如果实现了BeanNameAware接口可以获取到BeanName；如果实现了BeanFactoryAware接口可以获取到对象BeanFactory。(Spring会检测该对象是否实现了Aware接口，通过Aware类型的接口，可以拿到Spring容器的一些资源。) 执行BeanPostProcessor的前置处理方法postProcessBeforeInitialization(),对bean进行一些自定义的前置处理。 调用init初始化方法，(判断bean是否实现了initializingBean接口，如果实现了将会调用InitializingBean的afterPropertiesSet()初始化方法。如果XML中配置了init-method属性，会调⽤对应的初始化）。 执行BeanPostProcessor的后置处理方法postProcessAfterInitializtion()。（在此方法执行后会完成AOP的代理）。 初始化完成之后会将这个 bean 放入单例池。 4.销毁bean 初始化完成后，Bean就成功创建了，之后就可以使用这个Bean。 当Bean不再需要时，就会进行销毁。 Spring容器关闭时调用DisposableBean的destory()方法。 Bean的循环依赖 spring进行扫描-&gt;反射后封装成 X 的beanDefinition对象-&gt;放入beanDefinitionMap 遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象） 推断构造方法-&gt;准备开始进行实例 去单例池中查，如果没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中 属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X X又走一遍生命周期，当走到去二级缓存中找的时候找到了 Y 的objectFactory，完成依赖注入 往Y中注入X的objectFactory对象-&gt;完成循环依赖。 1、为什么要使用X的objectFacory对象而不是直接使用X对象？利于拓展，程序员可以通过beanPostProcess接口操作objectFactory对象生成自己想要的对象 2、是不是只能支持单例(scope&#x3D;singleton)而不支持原型(scope&#x3D;prototype)？是。因为单例是spring在启动时进行bean加载放入单例池中，在依赖的bean开始生命周期后，可以直接从二级缓存中取到它所依赖的bean的objectFactory对象从而结束循环依赖。而原型只有在用到时才会走生命周期流程，但是原型不存在一个已经实例化好的bean，所以会无限的创建-&gt;依赖-&gt;创建-&gt;依赖-&gt;…。 3、循环依赖是不是只支持非构造方法？是。类似死锁问题","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://aloctw.github.io/tags/Spring/"}]},{"title":"RabbitMQ消息丢失","slug":"RabbitMQ消息丢失","date":"2022-04-14T08:24:54.000Z","updated":"2022-07-20T14:35:56.824Z","comments":true,"path":"2022/04/14/RabbitMQ消息丢失/","link":"","permalink":"https://aloctw.github.io/2022/04/14/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1/","excerpt":"","text":"RabbitMQ消息丢失消息从生产到消费经过三个环节： 生产–&gt;MQ Broker –&gt; 消费 这三个环节都有丢失消息的可能。 一、生产者丢失消息&amp;emsp;&amp;emsp;原因：网络传输不稳定，从生产者到MQ的传输过程中，MQ未收到消息，而生产者认为任务完成不会重复发送，从而导致消息丢失。有两种方式可以解决该问题：事务机制和confirm通知机制。 方式一：事务机制&amp;emsp;&amp;emsp;RabbitMQ提供了事务功能，生产者发送消息之前开启事务 channel.txSelect，然后发送消息，如果消息没有成功接收则报异常，此时回滚事务，channel.txRollback，然后重试发送消息，成功则提交事务channel.txCommit。 // 开启事务 channel.txSelect; try { // 这里发送消息 } catch (Exception e) { channel.txRollback // 这里再次重发这条消息 } // 提交事务 channel.txCommit; &amp;emsp;&amp;emsp;但是注意，使用事务的方式非常消耗性能，大大降低 RabbitMQ 的效率，慎用！！！ 方式二：confirm通知&amp;emsp;&amp;emsp;RabbitMQ可以在生产者那里将信道设置开启confirm通知模式，每次产出的消息都会分配一个唯一的 id (从1开始)，如果消息成功写入 RabbitMQ 投递到匹配队列，则给生产者回传一个包含唯一id的确认 (Basic.Ack) 给生产者。 &amp;emsp;&amp;emsp;如果接收失败生产者则重发消息，或者设置超过一定时间没有得到消息回调也可以重发。 &amp;emsp;&amp;emsp;如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 &amp;emsp;&amp;emsp;RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 也可以设置 channel.basicAck 方法中的 multiple 参数，表示到这个序号之前的所有消息都已经得到了处理，注意辨别这里的确认和消费时候的确认之间的异同。 注意： 事务机制和 publisher confirm 机制两者是互斥的，不能共存。 事务机制和 publisher confirm 机制确保的是消息能够正确地发送至 RabbitMQ，这里的“发送至 RabbitMQ”的含义是指消息被正确地发往至 RabbitMQ 的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。 二、RabbitMQ丢失消息&amp;emsp;&amp;emsp;原因：RabbitMQ 接收到消息之后，当时是存在内存中的还未消费，此时 RabbitMQ 挂了，再次启动时，内存中的消息丢失。 开启RabbitMQ持久化&amp;emsp;&amp;emsp;当RabbitMQ接收到消息后，将消息持久化到磁盘，此时哪怕 RabbitMQ 挂了，重启之后消息也是还在的。 &amp;emsp;&amp;emsp;也可以联合之前设置的confirm通知，只有当 RabbitMQ 将消息持久化到磁盘才会回调返回 ack 消息，此时就算如果没持久化到磁盘就丢失了，生产者也会重发消息。 配置持久化： &amp;emsp;&amp;emsp;一、创建queue的时候将其设置为持久化，这样就可以保证RabbitMQ 持久化queue的元数据，但不会保存queue里面的数据。 &amp;emsp;&amp;emsp;二、将发送消息的 deliveryMode 设置为2，把消息设置为持久化，此时 RabbitMQ 就会把消息持久化到磁盘。 &amp;emsp;&amp;emsp;并且注意要同时设置这两个持久化才会起作用！！ 三、消费者丢失消息&amp;emsp;&amp;emsp;原因：RabbitMQ 的 ack 自动消息确认机制，当 autoAck &#x3D; true 的时候，RabbitMQ 会自动把发送出去的消息设置为确认，然后从内存或磁盘中删除，而不管消费者是否真正的接收到了消息，此时消费者宕机，所以导致消息丢失。 配置autoAck &#x3D; false&amp;emsp;&amp;emsp;将autoAck设置为false之后，消费者有足够时间处理消息，不用担心消费者未处理完成就宕机的问题，RabbitMQ 会一直等待消费者显示回调 Basic.Ack 命令。 &amp;emsp;&amp;emsp;并且可以通过 RabbitMQ 的WEB平台上查看消息参数，来监控查看消息的消费情况。 防止重复消费&amp;emsp;&amp;emsp;正常情况下，当消费者处理完消息之后会给消息队列发送确认通知到队列，队列收到后将消息从队列删除。但有时候网络传输故障，导致队列不知道消息已被处理，这个时候队列会将消息再次重复发送到另一个消费者，这个时候就出现消息重复消费的情况了。 解决：保证消息的作用的唯一性 做redis的set的操作，不用解决，因为无论set几次结果都是一样的，set操作本来就算幂等操作。 做数据库的insert操作，可以给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。 最终情况：可以准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。","categories":[],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://aloctw.github.io/tags/RabbitMQ/"}]},{"title":"Redis缓存异常：穿透、雪崩、击穿","slug":"Redis缓存异常：穿透、雪崩、击穿","date":"2022-03-25T08:15:00.000Z","updated":"2022-07-14T12:26:48.000Z","comments":true,"path":"2022/03/25/Redis缓存异常：穿透、雪崩、击穿/","link":"","permalink":"https://aloctw.github.io/2022/03/25/Redis%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%EF%BC%9A%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF/","excerpt":"","text":"Redis缓存异常一、缓存雪崩&amp;emsp;&amp;emsp;缓存雪崩是指缓存的 key 在同一时间大面积的失效，所以后面的请求都会落到数据库上面，造成数据库在短时间内承受大量请求而宕机。 解决方案： 缓存数据的过期时间设置随机，防止同一时间大量数据同时过期现象发生。 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 给每一个缓存数据增加响应的缓存标记，记录缓存是否失效，如果缓存标记失效则更新数据缓存。 二、缓存穿透&amp;emsp;&amp;emsp;缓存穿透是指用户请求缓存和数据库中都没有的数据，导致请求落在数据库上，造成数据短时间内承受大量请求而宕机。 解决方案： 可以在缓存中增加一个 key-null 值，用户请求时直接返回一个null值。缓存的有效时间可以设置短一点，设置太长可能导致正常情况也无法使用。 可以采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。 三、缓存击穿&amp;emsp;&amp;emsp;缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞，数据库瞬间压力过大宕机。 解决方案： 如果这个 key 被经常访问说明这是个热点 key ，可以设置这个热点 key 永不过期。 加互斥锁，使用 mutex 。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作，比如 Redis 的 SETNX 去set一个mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存； 也就是对缓存查询加锁，如果KEY不存在，就加锁，然后查数据库入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据。 四、缓存预热&amp;emsp;&amp;emsp;缓存预热是指系统上限之后，将相关的缓存数据直接加载到缓存当中，这样可以避免在用户请求的时候直接查询数据库，这样用户直接请求到已被加载到缓存中数据。 解决方案： 直接写个缓存刷新页面，上线前手工操作。 相关的数据量不大的时候，可以在项目启动时自动加载。 定时刷新缓存。 五、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？使用keys指令可以扫出指定模式的key列表。 但因为是单线程的，如果这个redis正在给线上的业务提供服务，那使用keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。 这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://aloctw.github.io/tags/Redis/"}]},{"title":"Redis非关系型数据库","slug":"Redis非关系型数据库","date":"2022-03-24T04:15:42.000Z","updated":"2022-07-14T12:26:32.000Z","comments":true,"path":"2022/03/24/Redis非关系型数据库/","link":"","permalink":"https://aloctw.github.io/2022/03/24/Redis%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"Redis&amp;emsp;&amp;emsp;Redis是一个使用C语言编写的、开源的高性能非关系型NoSQL键值对数据库。 &amp;emsp;&amp;emsp;Redis 可以存储键和五种不同类型的值之间的映射，键的类型只能为字符串String，值支持五种数据类型：String字符串、List列表、Set集合、Hash散列表、ZSet有序集合。 &amp;emsp;&amp;emsp;与传统数据库不同，Redis的数据是存在内存中，所以读写速度非常快，因此被广泛用于缓存方向，每秒可以处理超过10万次读写操作，另外Redis 也经常用来做分布式锁。 1、Redis优缺点优点： 读写性能优异，Redis读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。 支持数据持久化、支持AOF和RDB两种持久化方式。 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持String类型的Value外还支持hash、set、zset、list等数据结构。 支持主从复制、主机会自动将数据同步到从机，可以支持读写分离。 缺点： 数据库容量收到物理内存的限制，不能用作海量数据的高性能读写。 Redis 不具备自动容错和回复功能，主机从机的宕机会导致前端读写部分失败。 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂，后期运维较为麻烦。 2、持久化&amp;emsp;&amp;emsp;持久化：将内存中的数据持久化到磁盘当中，防止服务器宕机了内存数据丢失。 &amp;emsp;&amp;emsp;持久化机制：RDB (默认)、AOF RDB 快照持久化 (默认)&amp;emsp;&amp;emsp;RDB是Redis默认的数据持久化方式，按照一定的时间将内存的数据以快照的形式保存到硬盘当中，产生的数据文件为 dump.rdb。可以通过配置文件中的save参数来定义快照的周期。 优点： 只有一个文件dump.rdb，方便持久化。 容灾性好，一个文件可以保存到安全的磁盘。 性能最大化，可以fork一个子进程来完成写操作，让主进程继续处理指令，保证了Redis的高性能。 相对于数据集比较大时，比AOF的启动回复效率要高。 缺点： 数据安全性低，RDB是间隔一段时间进行持久化，如果持久化间隔时间中Redis发生故障，会发生数据丢失，所以更适合保存不是很严谨的数据。 AOF 指令持久化&amp;emsp;&amp;emsp;AOF： 将Redis执行的每次写操作指令以Redis命令单独记录到日志文件为 .aof文件，当重启Redis会重新将持久化的日志文件中回复数据。 &amp;emsp;&amp;emsp;当两种方式同时开启时，数据回复会优先选择 AOF方式。 优点： 数据安全，AOF持久化可以配置appendfsync属性，没进行一次写操作就记录到aof文件中一次。 通过append模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。 AOF机制的rewrite模式：文件过大时会对命名进行合并重写，当aof文件没被rewrite之前，可以删除其中的某些误操作的命名。 缺点： AOF 文件比RDB文件大，且回复速度慢。 数据集较大的时候，比RDB启动回复效率低。 &amp;emsp;&amp;emsp;一般来说，最好同时使用两种持久化方式，会优先载入AOF文件回复原始数据，通常情况下AOF保存的数据要比RDB完整一些。 &amp;emsp;&amp;emsp;如果对数据要去不是很严谨，可以承受部分数据的丢失，那么就可以支持RDB。 &amp;emsp;&amp;emsp;如果只支持AOF持久化，也不推荐，因为定时生成RDB快照非常便于进行数据库备份，而且RDB回复数据速度要快。 3、主从架构&amp;emsp;&amp;emsp;主从架构 (master-slave)，一主多从，主负责写操作，并且将数据复制到其他的Slave节点，从节点负责读操作，所有的读请求全部走从节点，这样也可以很轻松实现水平扩容，支撑读高并发。 &amp;emsp;&amp;emsp;redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发 Redis replication机制 Redis 采用异步方式复制数据到Slave节点，从2.8开始Slave node会周期性地确认自己每次复制的数据量。 一个Master node是可以配置多个Slave node的。 Slave node也可以连接其他Slave node。 Slave node在复制的时候，不会阻塞Master node的工作。 Slave node在复制的时候，也不会阻塞自己的查询操作，它会用旧的数据集来提供服务，但是当复制完成需要删除旧的数据集，加载新数据集的时候会暂停对外的服务。 原理：&amp;emsp;&amp;emsp;当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。 &amp;emsp;&amp;emsp;如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件， &amp;emsp;&amp;emsp;同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中， &amp;emsp;&amp;emsp;接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。 &amp;emsp;&amp;emsp;slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。 当从库和主库建立MS关系后，会向主数据库发送SYNC命令 主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来 当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis 从Redis接收到后，会载入快照文件并且执行收到的缓存的命令 之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致 缺点：&amp;emsp;&amp;emsp;所有的Slave节点的复制和同步都是由Master节点来处理，会造成Master节点的压力太大。 4、哨兵模式哨兵：Sentinel，是Redis集群架构中非常重要的一个组件。 集群监控：负责监控Redis Master和Slave进程是否正常工作。 消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息给系统管理员。 故障转移：如果某个Master node挂掉了，会自动通过分布选举机制判定，并转移到Slave node 配置中心：如果故障转移发生了，会通知Client客户端新的Master地址。 哨兵用于实现集群模式的高可用，本身也是分布式的，作为一个哨兵集群去运行，相互协同工作。 故障转移时，判断一个Master node是否宕机了，需要大部分的哨兵同意才行，涉及到了选举机制的问题。 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制的重要组成部分的故障转移系统本身还是一个单点的，那就非常坑了。 &amp;emsp;&amp;emsp;哨兵至少需要三个实例，才能保持本身的健壮性。 &amp;emsp;&amp;emsp;哨兵+主从部署架构，是不保存数据百分百不丢失的，只能保证Redis集群的高可用性。 &amp;emsp;&amp;emsp;对于哨兵+主从部署架构，需要在测试环境和生产环境中充分的进行测试。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://aloctw.github.io/tags/Redis/"}]},{"title":"springboot自动配置与运行原理","slug":"springboot自动配置与运行原理","date":"2022-03-22T10:50:43.000Z","updated":"2022-07-14T12:26:08.000Z","comments":true,"path":"2022/03/22/springboot自动配置与运行原理/","link":"","permalink":"https://aloctw.github.io/2022/03/22/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、springboot自动配置1.启动器springboot将各种开发功能的环境抽取出来做成了单独的starter(启动器)，开发时只需要在pom.xml中引入启动器，就可以将相关的依赖环境导入进来，所以在使用时做什么功能就引入对应的启动器就可以了。 启动器： spring-boot-starter &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> springboot将依赖的版本用父项目进行管理，在导入依赖时默认不需要指明版本，除非使用的依赖没有在父项目中。 &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.7.0&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> 但是在这里我们并没有看见版本的管理，这里主要是对项目资源过滤以及插件进行管理，在spring-boot-starter-parent点进去可以发现： &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-dependencies&lt;/artifactId> &lt;version>2.7.0&lt;/version> 还有这样一个父依赖，这里才是真正进行版本管理的基地所在。 2.启动类启动类是程序启动的入口，包括了tomcat等服务的启动： @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 看上去简简单单，普普通通，只有几行，但是其中的流程是比较复杂的。 ①、@SpringBootApplication：标注了这个类是springboot的主配置类，并且说明这是一个springboot应用，通过运行它标注的main方法来启动应用，如果没有它程序无法启动。 源码分析：进去之后可以发现在它上面还有注解 //四个元注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //springboot配置类 @SpringBootConfiguration //自动配置 @EnableAutoConfiguration //自动扫描，当前包及其子包， @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { @AliasFor( annotation = EnableAutoConfiguration.class ) ...... } @SpringBootConfiguration：标注当前类为springboot配置类 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented //配置类 @Configuration @Indexed public @interface SpringBootConfiguration { @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true; } 进去之后发现有**@Configuration**，说明这是一个配置类相当于之前的java配置代替xml配置。 @Component public @interface Configuration { @AliasFor( annotation = Component.class ) 继续进去查看，**@Component**一个非常熟悉的注解，说明这个启动类本身也是被spring容器所管理，是其中的一个负责启动的组件。 ②、@EnableAutoConfiguration：在启动类中这个注解，负责开启自动配置，解放双手。 在之前需要我们在xml或者java中配置的相关组件，springboot可以实现自动配置。 继续深入挖掘： //自动配置包 @AutoConfigurationPackage //给容器导入组件 @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?>[] exclude() default {}; String[] excludeName() default {}; } @AutoConfigurationPackage：实现自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage { String[] basePackages() default {}; Class&lt;?>[] basePackageClasses() default {}; } @Import({Registrar.class})：在spring容器中导入组件。 Registrar.class：把启动类所在包及其子包的所有组件进行扫描，并导入。 回到上一步： @Import({AutoConfigurationImportSelector.class}) AutoConfigurationImportSelector：自动配置导入选择器 源码追溯： 第一：getCandidateConfigurations()方法，获取候选的配置组件。 并且getSpringFactoriesLoaderFactoryClass() 返回了之前看的启动自动导入配置文件的注解类；EnableAutoConfiguration protected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String> configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\"); return configurations; } 第二：可以看到调用了SpringFactoriesLoader.loadFactoryNames()方法，点进去看到调用了loadSpringFactories()方法， public static List&lt;String> loadFactoryNames(Class&lt;?> factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); } 第三：进去loadSpringFactories()方法，注意三个地方： 1.cache.get(classLoader)：获得classLoader 这里返回EnableAutoConfiguration标注的类本身。 2.classLoader.getResources(FACTORIES_RESOURCE_LOCATION)：这里的FACTORIES_RESOURCE_LOCATION进去后是获取一个资源对象： META-INF&#x2F;spring.factories 。 3.while (urls.hasMoreElements()) {}： 资源遍历并封装成为一个Properties private static Map&lt;String, List&lt;String>> loadSpringFactories(ClassLoader classLoader) { Map&lt;String, List&lt;String>> result = cache.get(classLoader); // 获得classLoader 这里返回EnableAutoConfiguration标注的类本身 if (result != null) { return result; } result = new HashMap&lt;>(); try { Enumeration&lt;URL> urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); // 这里的FACTORIES_RESOURCE_LOCATION进去后是获取一个资源对象： *META-INF/spring.factories* 。 // 资源遍历并封装成为一个Properties while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?> entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue()); for (String factoryImplementationName : factoryImplementationNames) { result.computeIfAbsent(factoryTypeName, key -> new ArrayList&lt;>()) .add(factoryImplementationName.trim()); } } } 第四：查看一下刚刚看到的那个资源文件对象META-INF&#x2F;spring.factories， 可以发现有很多的配置文件 随便找一个配置OnWebApplicationCondition 自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"https://aloctw.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://aloctw.github.io/tags/springboot/"}]},{"title":"ajax的请求方式","slug":"ajax向后端发送请求","date":"2022-03-21T08:25:52.000Z","updated":"2022-07-20T11:50:03.614Z","comments":true,"path":"2022/03/21/ajax向后端发送请求/","link":"","permalink":"https://aloctw.github.io/2022/03/21/ajax%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"几种简单发送AJAX请求的方式几种发送AJAX请求的方式概念Ajax &#x3D; 异步 Javascript + XML ， 是一种用于创建快速动态网页的技术。 优点可以实现不重新加载整个网页的情况下，对网页的某部分进行更新。 浏览器是单线程的，如果要实现多任务，为了防止任务卡主或者等待情况，就需要异步概念。 同步和异步的区别同步代码：代码是顺序执行的，根据代码定义顺序往下执行。异步代码：代码的执行顺序不是按定义执行，往往同步的代码先执行，再执行异步代码。XHR(XMLHttpRequest)对象XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用 发送ajax请求如果是get请求，参数直接拼接在url上发送。 post请求 参数放在请求体里面 post请求需要设置请求头，需要在open方法调用后再执行 xhr.setRequestHeader 例子 1、Get 请求通过 new 关键字 创建 xhr 实例 XMLHttpRequest const(局部) var(全局) const xhr = new XMLHttpRequest(); //2.xhr.open设置get请求的数据 xhr.open('请求方式','url') xhr.open('get','http://127.0.0.1:8080/validate?userName=tom') //3.1获取服务端响应的数据 xhr.onload = function(){ //3.2把json字符串转换为json对象 const res = JSON.parse(xhr.responseText); console.log(res) } //4.xhr.send发送数据 xhr.send(); 2、post 请求//1.创建实例 const xhr = new XMLHttpRequest(); //2.xhr.open 设置请求数据 xhr.open('post','http://127.0.0.1:8080/login') //3.设置请求头 xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') //4.获取服务端响应的数据 xhr.onload = function(){ //4.1把json字符串转换为json对象 const res = JSON.parse(xhr.responseText); if(res.code === 200){ console.log(res.msg) } //5.post发送数据，在send里面发送参数 xhr.send('userName=tom'); 3、jQuery发送ajax请求$.ajax({type,url,data,success}) type: 请求的方式，默认是一个get请求 url: 请求的地址 data: 请求的参数 ，接收的是一个对象{ key: value } success: 成功回调，回调的第一个参数就是服务端返回的数据，他的格式是JSON对象 3.1jquery 的get请求//date请求参数可以拼接到url后面 $.ajax({ type:'get', //请求方式 url:'http://127.0.0.1:8080/my.do', //请求地址 data:{id:1}, //请求参数 success:function(res){ //如果获取数据成功，对数据进行处理 //res是服务器传递回来的数据，已经经过转换的JSON对象 if(res.code === 200){ console.log(res.data) } 3.2jquery 的post请求//post请求 $.ajax({ type:'post', //请求方式 url:'http://127.0.0.1:8080/my.do', //请求地址 data:{id:1}, //请求参数 success:function(res){ //如果获取数据成功，对数据进行处理 //res是服务器传递回来的数据，已经经过转换的JSON对象 if(res.code === 200){ console.log(res.data) } 4、$.get发送请求$.get(‘请求url’, ‘请求参数’, ‘请求回调函数’) function getJoke() { $.get('http://127.0.0.1:8080/my.do', { jokeId: 1 }, function(res) { $('#joke').html(res.data.content) }) } 5、$.post发送请求$.post(‘请求URL’, ‘请求参数’, ‘回调函数’) $.post('http://127.0.0.1:3001/my.do', { content: '转换的内容' }, function(res) { console.log(res) })","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://aloctw.github.io/tags/Spring/"}]},{"title":"Spring_IOC操作bean(基于注解)","slug":"Spring-IOC操作bean-基于注解","date":"2022-03-20T01:47:54.000Z","updated":"2022-07-14T12:25:50.000Z","comments":true,"path":"2022/03/20/Spring-IOC操作bean-基于注解/","link":"","permalink":"https://aloctw.github.io/2022/03/20/Spring-IOC%E6%93%8D%E4%BD%9Cbean-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"[TOC] Spring_IOC操作bean管理（基于注解） 格式：@注解名称（属性名&#x3D;属性值，属性名&#x3D;属性值，……） 注解可以作用在类，属性，方法。 使用注解的目的：简化xml配置 1、基于注解创建对象：spring提供了四种创建对象的注解： @Component 全局都可以使用 @Service：一般用于Service层 @Controller：一般用于web层 @ Repository：一般用于Dao层 这四个注解作用一样，只能注解在类上面，都可以创建对象，但分类后可读性更强。 第一步：引入依赖包：使用注解方式，有用到AOP编程，所以需要导入AOP依赖包 第二步：引入约束文件，并开启组件扫描：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"> &lt;!--component-scan是组件扫描属性，base-package指定扫描那个包，被扫描的包下所有使用注解的类及属性都归Spring管理--> &lt;context:component-scan base-package=\"com.dyh.demo.pojo\"/> &lt;/beans> 第三步：在com.dyh.demo.pojo包下创建类并加上注解/** * 这里通过@Component注解来创建对象,括号中value的值等同于之前xml创建对象使用的id,为了后面使用时通过id来获取对象 * 括号中的内容也可以省略,默认是类名并且首字母小写 * 可以用其他三个注解 */ @Component public class student { private String name; private int age; 第四步：getBean()获取对象：public class Test { public static void main(String[] args) { ApplicationContext ac = new ClassPathXmlApplicationContext(\"Beans.xml\"); // 注意：Bean的id名默认会首字母小写，所以在这里getBean的时候注意id名首字母小写 student student = ac.getBean(\"student\",student.class); System.out.println(student); } } 组件扫描的细节配置：&amp;emsp;&amp;emsp;① use-default-fileters属性设置为false表示不使用默认过滤器，通过子标签include-filter来设置只扫描com.oymn包下的所有@Controller修饰的类 。 &amp;emsp;&amp;emsp;注意use-default-filters 属性的默认值为 true，使用默认的 Filter 进行包扫描，默认的 Filter 对标有 @Component,@Service,@Controller和@Repository 的注解的类进行扫描 。 &lt;context:component-scan base-package=\"com.oymn\" use-default-filters=\"false\"> &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &amp;emsp;&amp;emsp;②子标签exclude-filter设置哪些注解不被扫描，例子中为@Controller修饰的类不被扫描。 &lt;context:component-scan base-package=\"com.oymn\"> &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/> &lt;/context:component-scan> &amp;emsp;&amp;emsp;在使用 use-default-filters 属性时要分清楚需要扫描哪些包，是不是需要使用默认的 Filter 进行扫描。即 use-default-filters&#x3D;”false” 需要和 context:include-filter 一起使用，不能和 context:exclude-filter 属性一起使用。 2、基于注解进行属性注入：@Autowired：根据属性类型自动装配，","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://aloctw.github.io/tags/Spring/"},{"name":"框架","slug":"框架","permalink":"https://aloctw.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"注解","slug":"注解","permalink":"https://aloctw.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"优秀的Spring框架","slug":"优秀的Spring框架","date":"2022-03-16T01:40:54.000Z","updated":"2022-07-14T12:25:18.000Z","comments":true,"path":"2022/03/16/优秀的Spring框架/","link":"","permalink":"https://aloctw.github.io/2022/03/16/%E4%BC%98%E7%A7%80%E7%9A%84Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"[TOC] 一、Spring框架概述Spring 是轻量级的开源的 JavaEE 框架。 Spring 可以解决企业应用开发的复杂 Spring 有两个核心部分：IOC 和 Aop （1）IOC：控制反转，把创建对象过程交给 Spring 进行管理 （2）Aop：面向切面，不修改源代 码进行功能增强 Spring 特点 ： （1）方便解耦，简化开发 （2）Aop 编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低 API 开发难度 二、IOC容器1、IOC容器概念 IOC：控制反转，把对象创建和对象的调用过程交给Spring进行管理。 目的：降低耦合度。 底层原理：XML，反射，工厂模式。 Spring提供IOC容器的两种方式(两个接口)： &amp;emsp;&amp;emsp;BeanFactory：Spring内部使用的接口，不提倡开发人员使用。 &amp;emsp;&amp;emsp;&amp;emsp;特点：加载配置文件时不会创建对象，只有在获取对象（getBean()）时才会把配置文件里的对象进行创建。实现类：xmlBeanFactory。 &amp;emsp;&amp;emsp;ApplicationContext：BeanFactory的子接口，提供了更多更强大的功能，一般由开发人员使用。 &amp;emsp;&amp;emsp;&amp;emsp;特点：加载配置文件时就将bean创建为对象。实现类：FileSystemApplicationContext(绝对路径)、ClassPathXmlApplicationContext(相对路径，src开始)。 2、IOC操作Bean管理(基于XML)Bean管理是指两个操作：Spring创建对象 和 Spring注入属性 Bean管理有两种操作方式：基于xml配置文件方式实现 和 基于注解方式实现 （1）基于Xml方式创建对象 在Spring配置文件中使用bean标签来创建对象 bean标签有很多属性，常用属性： id：唯一标识 class：类路径 创建对象时，默认执行无参构造函数 （2）基于Xml方式注入属性第一种：使用Set方法注入：注意该类要先提供Set()方法 public class student { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 注入属性简易值： &lt;bean id=\"Student\" class=\"com.dyh.demo.pojo.student\"> &lt;property name=\"name\" value=\"张三\"/> &lt;property name=\"age\" value=\"18\"/> &lt;/bean> 测试方法： ApplicationContext ac = new ClassPathXmlApplicationContext(\"Beans.xml\"); student student = ac.getBean(\"Student\",student.class); System.out.println(student); 第二种：采用有参构造注入：提供构造方法 public student(String name, int age) { this.name = name; this.age = age; } xml配置文件中通过constructor-arg标签进行属性注入 ，其中的标签属性name的值是构造方法中参数列表的形参，并且必须所有形参都要值，否则编译报错。 &lt;bean id=\"Student\" class=\"com.dyh.demo.pojo.student\"> &lt;constructor-arg name=\"name\" value=\"张三\"/> &lt;constructor-arg name=\"age\" value=\"18\"/> &lt;/bean> 第三种：接口注入（了解即可）：&amp;emsp;&amp;emsp;这里的接口并不是指的java中定义方法的interface接口，而是广义上的资源服务接口，对接的是某处资源的门户，可以通过此门户访问其资源。但是这种用接口注入依赖的方法比较复杂繁琐不方便，在实际开发过程中很少使用。 &amp;emsp;&amp;emsp;有的时候资源并非来自于自身系统，比如在Tomcat下配置数据库资源，然后通过JNDI的形式去获取它，在Tomcat服务器的context.xml文件中加入自己的一个资源，如下： &lt;Context> &lt;! -- name 是 JNDI 名称 type 是数据源都要实现的一个接口 url 是数据库的 jdbc 连接 username 用户名 password 数据库密码 --> &lt;Resource name=\"jdbc/ssm\" auth=\"Container\" type=\"javax.sql.DataSource\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/ssmzeroDateTimeBehavior=convertToNull\" username=\"root\" password=\"123456\" /> &lt;/Context> &amp;emsp;&amp;emsp;并在WEB工程目录中导入JDBC驱动包，然后使用Spring的机制，用JNDI获取Tomcat启动的数据库连接池，这样就可以在Spring的IOC容器下获取Tomcat所管理的数据库连接池了，如下： &lt;bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"> &lt;property name=\"jbdiName\"> &lt;value>java:comp/env/jdbc/ssm&lt;/value> &lt;/property> &lt;/bean> 第四种：命名空间注入（了解即可）首先在xml配置文件的约束中引入对应的命名空间和xml模式文件，并在bean标签中操作。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"> 注意“c”、”p”、”util”这三行代码，他们定义了xml的命名空间，这样才能在内容中使用p、c、util的前缀定义。 c命名空间采用构造方法注入,需要提供有参构造方法，c:_0代表构造方法的第一个参数，c:_1代表第二个参数，以此类推。 p命名空间采用设值(Set方法)注入，需要提供Set方法，其中 **p:属性名&#x3D;”属性值”**，其他以此类推。 util命名空间需要引入XSD约束文件，通过命名空间util定义Map、Set、List集合对象。list-ref代表引用List属性，他的值是上下文定义的bean。 &lt;bean id=\"Student1\" class=\"com.dyh.demo.pojo.student\" c:_0=\"张三\" c:_1=\"20\"c:_2-ref=\"list\"/> &lt;bean id=\"Student2\" class=\"com.dyh.demo.pojo.student\" p:name=\"李四\" p:age=\"18\"/> &lt;util:list id=\"list\"> &lt;ref bean=\"Student1\"/> &lt;ref bean=\"Student2\"/> &lt;/util:list> &lt;bean id=\"Student3\" class=\"com.dyh.demo.pojo.student\"p:name=\"三\"p:age=\"18\"p:list-ref=\"list\"/> （3）XML注入其他属性第一个：null空值 &lt;!--配置Student对象--> &lt;bean id=\"user\" class=\"com.dyh.demo.pojo.student\"> &lt;property name=\"name\"> &lt;null/> &lt;/property> &lt;/bean> 第二个：属性值中的特殊符号&amp;emsp;&amp;emsp;特殊符号是指在xml文件中会被xml解析器解析的符号，比如：&lt; &gt; &#x3D; &amp; 等符号，如果直接在属性值value中声明会报解析错误。需要通过 **&lt;! CDATA [忽略检查的文本]]&gt; ** ,该标签中的内容都会一视同仁的当做纯文本字符数据看待，XMl解析器将其中的内容忽略。 &lt;bean id=\"student\" class=\"com.dyh.demo.pojo.student\"> &lt;property name=\"name\"> &lt;value>&lt;![CDATA[&lt;尖括号被xml忽略检查>]]>&lt;/value> &lt;/property> &lt;/bean> 第三个：注入属性—外部bean有两个类：UserService和UserDaoImpl，其中UserDaoImpl实现UserDao接口 public class UserService { private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } public void add(){ System.out.println(\"add\"); } } 通过 ref 来指定创建userDaoImpl &lt;bean id=\"userDaoImpl\" class=\"com.dyh.demo.pojo.UserDaoImpl\">&lt;/bean> &lt;bean id=\"userService\" class=\"com.dyh.demo.pojo.UserService\"> &lt;property name=\"userDao\" ref=\"userDaoImpl\">&lt;/property> &lt;/bean> 第四个：注入属性—内部bean 不通过ref属性，而是通过嵌套一个bean标签实现 &lt;!--内部 bean--> &lt;bean id=\"emp\" class=\"com.dyh.demo.pojo.Emp\"> &lt;!--设置两个普通属性--> &lt;property name=\"ename\" value=\"lucy\">&lt;/property> &lt;property name=\"gender\" value=\"女\">&lt;/property> &lt;!--设置对象类型属性--> &lt;property name=\"dept\"> &lt;bean id=\"dept\" class=\"com.dyh.demo.pojo.Dept\"> &lt;property name=\"dname\" value=\"人事部\">&lt;/property> &lt;/bean> &lt;/property> &lt;/bean> 第五个：注入属性—级联赋值方法一：也就是上面所说的外部bean，通过ref属性来获取外部bean 方法二：emp类中有ename和dept两个属性，其中dept有dname属性，写法二需要emp提供dept属性的get方法 &lt;!--级联赋值--> &lt;bean id=\"emp\" class=\"com.dyh.demo.pojo.Emp\"> &lt;!--设置两个普通属性--> &lt;property name=\"ename\" value=\"lucy\">&lt;/property> &lt;property name=\"gender\" value=\"女\">&lt;/property> &lt;!--写法一--> &lt;property name=\"dept\" ref=\"dept\">&lt;/property> &lt;!--写法二--> &lt;property name=\"dept.dname\" value=\"人事部\">&lt;/property> &lt;/bean> &lt;bean id=\"dept\" class=\"com.dyh.demo.pojo.Dept\"> &lt;property name=\"dname\" value=\"人事部\">&lt;/property> &lt;/bean> 第六个：注入集合 数组属性&amp;emsp;&amp;emsp;在集合中注入值，也可以注入对象类型，但是该集合泛型或类型必须是Object类型或对应对象的类型，否则类型不匹配，注入失败。 实体类： public class student { private String[] courses; private List&lt;Object> list; private Map&lt;String, Object> map; private Set&lt;Object> set; private Properties pro; public void setPro(Properties pro) { this.pro = pro; } public void setCourses(String[] courses) { this.courses = courses; } public void setList(List&lt;Object> list) { this.list = list; } public void setMap(Map&lt;String, Object> map) { this.map = map; } public void setSet(Set&lt;Object> set) { this.set = set; } @Override public String toString() { return \"student{\" + \"courses=\" + Arrays.toString(courses) + \", list=\" + list + \", map=\" + map + \", set=\" + set + \", pro=\" + pro + '}'; } } 在xml配置文件中注入值： &lt;bean id=\"student1\" class=\"com.dyh.demo.pojo.student\"/> &lt;bean id=\"student2\" class=\"com.dyh.demo.pojo.student\"/> &lt;bean id=\"student\" class=\"com.dyh.demo.pojo.student\"> &lt;property name=\"courses\"> &lt;array> &lt;value>张三&lt;/value> &lt;value>李四&lt;/value> &lt;value>王五&lt;/value> &lt;/array> &lt;/property> &lt;property name=\"list\"> &lt;list> &lt;value>张三&lt;/value> &lt;value>李四&lt;/value> &lt;value>王五&lt;/value> &lt;ref bean=\"student1\"/> &lt;ref bean=\"student2\"/> &lt;/list> &lt;/property> &lt;property name=\"map\"> &lt;map> &lt;entry key=\"1\" value=\"张三\"/> &lt;entry key=\"2\" value=\"李四\"/> &lt;entry key=\"3\" value=\"王五\"/> &lt;entry key=\"4\" value-ref=\"student1\"/> &lt;entry key=\"5\" value-ref=\"student2\"/> &lt;/map> &lt;/property> &lt;property name=\"set\"> &lt;set> &lt;value>张三&lt;/value> &lt;value>李四&lt;/value> &lt;value>王五&lt;/value> &lt;ref bean=\"student1\"/> &lt;ref bean=\"student2\"/> &lt;/set> &lt;/property> &lt;property name=\"pro\"> &lt;props> &lt;prop key=\"1\">张三&lt;/prop> &lt;prop key=\"2\">李四&lt;/prop> &lt;prop key=\"3\">王五&lt;/prop> &lt;/props> &lt;/property> &lt;/bean> &amp;emsp;&amp;emsp;也可以把集合注入部分提取出来，使用util标签，使得不同的bean都可以使用，提高代码复用性与可读性。 &lt;util:list id=\"list\"> &lt;ref bean=\"Student\"/> &lt;ref bean=\"Student\"/> &lt;/util:list> &lt;bean id=\"Student2\" class=\"com.dyh.demo.pojo.student\" p:name=\"张三\"p:age=\"18\"p:list-ref=\"list\"/> （4）xml自动装配： 根据指定的装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入 根据属性名称自动装配：要求 emp中属性的名称dept 和 bean标签的id值dept 一样，才能识别 &lt;!--指定autowire属性值为byName--> &lt;bean id=\"emp\" class=\"com.dyh.demo.pojo.Emp\" autowire=\"byName\">&lt;/bean> &lt;bean id=\"dept\" class=\"com.dyh.demo.pojo.Dept\">&lt;/bean> 根据属性类型自动装配：要求同一个xml文件中不能有两个相同类型的bean，否则无法识别是哪一个 &lt;!--指定autowire属性值为byType--> &lt;bean id=\"emp\" class=\"com.dyh.demo.pojo.Emp\" autowire=\"byType\">&lt;/bean> &lt;bean id=\"dept\" class=\"com.dyh.demo.pojo.Dept\">&lt;/bean> （5）外部properties属性文件操作bean：很多时候资源来自于系统外部，比如配置数据库信息 ①导入Druid连接池jar包： ②创建外部properties属性文件，配置数据库信息： ③bean配置：引入context名称空间，并通过context标签引入外部属性文件，使用EL表达式“${}”来获取文件中对应的值 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"> &lt;context:property-placeholder location=\"jdbc.properties\"/> &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"> &lt;property name=\"driverClassName\" value=\"${prop.driverClassName}\"/> &lt;property name=\"url\" value=\"${prop.url}\"/> &lt;property name=\"username\" value=\"${prop.username}\"/> &lt;property name=\"password\" value=\"${prop.password}\"/> &lt;/bean> 3、Bean 的作用域与生命周期①、作用域 Scope Description singleton Spring默认的选项，单例，每个bean只有在初始化时创建一个对象。 prototype 原型，多例，可以手动设置，在getBean()时创建对象。 request 将单个bean作用于单个HTTP请求的生命周期，每个HTTP请求都有自己的bean实例，该实例是在单个bean定义的基础上创建的，仅在web项目的SpringApplicationContext上下文中有效。 session 将单个bean定义作用于HTTP会话的生命周期，仅在web项目的SpringApplicationContext上下文中有效。 application 将单个bean定义作用于Servletcontext的生命周期。 仅在web项目的SpringApplicationContext上下文中有效。 websocket 将单个bean定义作用于WebSocket 的生命周期。仅在web项目的SpringApplicationContext上下文中有效。 在Spring中，默认情况下的Bean是单例对象。 通过bean标签的scopo属性来设置单实例还是多实例。 singleton：默认值，表示单实例对象。加载配置文件时就会创建单实例对象。 prototype：表示多实例对象。不是在加载配置文件时创建对象，在调用getBean方法时创建多实例对象。 ②、生命周期&amp;emsp;&amp;emsp;Spring IoC容器对于管理的bean，在整个bean生命周期内，Spring IoC容器为我们提供了一些生命周期方法（钩子方法），我们可以给出钩子方法的具体实现，然后Spring容器会在相应的时机调用这些钩子方法。 Bean 生命周期的整个执行过程描述如下: Spring 启动，查找并加载需要被 Spring 管理的 Bean，对 Bean 进行实例化。 对 Bean 进行属性注入。 如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。 如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。 如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。 如果 Bean 实现了 BeanPostProcessor 接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。 如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。 如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。 如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。 如果在 中指定了该 Bean 的作用域为 singleton，则将该 Bean 放入 Spring IoC 的缓存池中，触发 Spring 对该 Bean 的生命周期管理；如果在 中指定了该 Bean 的作用域为 prototype，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。 如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法销毁 Bean；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。 代码演示： 实体类 package com.dyh.pojo; import org.springframework.beans.BeansException; import org.springframework.beans.factory.*; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; /** * ClassName: Person * Package: com.dyh.pojo * Description: * @Date: 2022/4/21 16:17 * @Author: yangzhihong */ public class Person implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean, DisposableBean { private String name; public Person() { System.out.println(\"step1: 调用无参构造方法\"); } public String getName() { return name; } public void setName(String name) { System.out.println(\"step2: 调用了set方法\"); this.name = name; } // 自定义初始化方法 public void myInit() { System.out.println(\"step8: 自定义初始化方法 myInit\"); } // 自定义销毁方法 public void myDestroy() { System.out.println(\"step12: 自定义销毁方法 myDestroy\"); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + '}'; } @Override public void setBeanName(String s) { System.out.println(\"step3: 调用了BeanNameAware接口中的setBeanName方法：\" + s); } @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { System.out.println(\"step4: 调用BeanFactoryAware接口中setBeanFactory方法：\" + beanFactory); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\"step5: 调用ApplicationContextAware接口中setApplicationContext方法：\" + applicationContext); } @Override public void afterPropertiesSet() throws Exception { System.out.println(\"step7: 调用了InitializingBean接口的afterPropertiesSet方法\"); } public void show() { System.out.println(\"step10: 成员方法 show方法\"); } @Override public void destroy() throws Exception { System.out.println(\"step11: 调用了DisposableBean接口的destroy方法\"); } } 自定义Bean后处理器,也是一个bean，需要被spring容器管理 package com.dyh.processor; import com.dyh.pojo.Person; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; /** * ClassName: MyBeanPostProcessor * Package: com.dyh.processor * Description: 自定义Bean后处理器,也是一个bean，需要被spring容器管理 * * @Date: 2022/4/21 16:51 * @Author: yangzhihong */ public class MyBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"step6: bean后处理器的前置方法:\" + bean); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"step9: bean后处理器的后置方法:\" + bean); return bean; } } xml配置文件 &lt;!-- 注册bean后处理器 --> &lt;bean class=\"com.dyh.processor.MyBeanPostProcessor\"/> &lt;!-- bean标签 init-method属性：关联自定义初始化方法 destroy-method属性： 关联自定义销毁方法 --> &lt;bean id=\"per\" class=\"com.dyh.pojo.Person\" init-method=\"myInit\" destroy-method=\"myDestroy\"> &lt;!--property标签可以给属性注入初始值 DI注入：给bean指定的属性注入初始值 name属性： 设置属性名称 value属性： 设置属性的基础值，只能设置基本数据类型和String ref属性： 设置对象类型 Spring属性注入依赖的是set方法 --> &lt;property name=\"name\" value=\"张三\"/> &lt;/bean> 测试 public static void main(String[] args) { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); Person per = ac.getBean(Person.class); per.show(); // ApplicationContext没有关闭方法，但是实现类有 ClassPathXmlApplicationContext context = (ClassPathXmlApplicationContext) ac; context.close(); } 自定义Bean的生命周期&amp;emsp;&amp;emsp;我们可以在 Spring Bean 生命周期的某个特定时刻，指定一些生命周期回调方法完成一些自定义的操作，对 Bean 的生命周期进行管理。Bean 的生命周期回调方法主要有两种： 初始化回调方法：在 Spring Bean 被初始化后调用，执行一些自定义的回调操作。 销毁回调方法：在 Spring Bean 被销毁前调用，执行一些自定义的回调操作。 我们可以通过以下 3 种方式自定义 Bean 的生命周期回调方法： 通过接口实现 通过 XML 配置实现 使用注解实现 如果一个 Bean 中有多种生命周期回调方法时，优先级顺序为：注解 &gt; 接口 &gt; XML 配置。","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://aloctw.github.io/tags/Spring/"},{"name":"框架","slug":"框架","permalink":"https://aloctw.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"数据库系统概论","slug":"数据库系统概论","date":"2022-03-14T08:41:07.000Z","updated":"2022-07-14T12:24:58.000Z","comments":true,"path":"2022/03/14/数据库系统概论/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/","excerpt":"","text":"数据系统系统一、第一篇1、数据库的四个基本概念①、数据：描述事务的符号记录 ②、数据库：概括地讲，数据库具有永久储存、有组织、可共享的三个基本特点。 &amp;emsp;&amp;emsp;严格来说：数据库是长期储存在计算机内、有组织、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 ③、数据库管理系统：是位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件。 主要功能： 数据定义功能； 数据组织、存储和管理； 数据操纵功能； 数据库的事务管理和运行管理； 数据库的建立和维护功能； 其他功能（通信功能、数据转换功能、互访和互操作功能）； ④、数据库系统：是由数据库、数据管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理、和维护数据的系统。 2、用户访问数据库的过程图 3、数据库的发展历史阶段 ①、人工管理阶段：数据不保存、不共享、不具有独立性。 ③、文件系统管理阶段：可保存但共享性差、冗余度高、独立性差。 ④、数据库管理系统：数据库系统的出现使得信息系统从以 加工数据的程序为中心 转向 共享的数据库为中心 的阶段，实现整体数据的结构化。 数据的共享性高、冗余度低且易扩充；数据共享可以大大减少数据冗余、节约储存空间。 数据的独立性高： &amp;emsp;&amp;emsp;物理独立性：是指用户的应用程序与数据库的物理存储是相互独立的。 &amp;emsp;&amp;emsp;逻辑独立性：是指用的应用程序与数据库的逻辑结构是相互独立的。 数据由数据库管理系统统一管理和控制。 4、数据模型&amp;emsp;&amp;emsp;有两类模型：概念模型+逻辑模型 和 物理模型。 &amp;emsp;&amp;emsp;人们先将现实世界抽象为信息世界，然后将信息世界转化为机器理解的数据世界。 ①、概念模型：也称为信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。 实体：客观存在并可相互区别的事物。人 属性：实体所具有的某一特性。人的鼻子嘴巴 码：唯一标识实体的属性。学号，在mysql中称为键 实体型：用实体名及其属性集合来抽象和刻画同类实体。含有嘴巴鼻子的人 实体集：同一类型实体的集合。学校 联系：实体之间的联系通常是指不同实体集之间的联系，实体之间的联系有一对一、一对多和多对多等多种联系。 概念模型的一种表示方法：实体—联系方法。 用ER图来描述现实世界的概念模型，E-R方法也称为E-R模型。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://aloctw.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"关于MyBatis_缓存","slug":"关于MyBatis-缓存","date":"2022-02-12T07:56:25.000Z","updated":"2022-07-14T12:06:48.000Z","comments":true,"path":"2022/02/12/关于MyBatis-缓存/","link":"","permalink":"https://aloctw.github.io/2022/02/12/%E5%85%B3%E4%BA%8EMyBatis-%E7%BC%93%E5%AD%98/","excerpt":"","text":"关于MyBatis_缓存一、MyBatis缓存简介MyBatis是常见的Java数据库访问层框架，MyBatis中允许使用缓存，缓存一般都放置在可高速读&#x2F;写的存储器上，比如服务器的内存，它能够有效提高系统的性能。因为数据库在大部分场景下是把存储在磁盘上的数据索引出来。从硬件的角度分析，索引磁盘是一个较为缓慢的过程，读取内存或者高速缓存处理器的速度要比读取磁盘快得多，其速度是读取硬盘的几十倍到上百倍,但是内存和高速缓存处理器的空间有限，所以一般只会把那些常用且命中率高的数据缓存起来，以便将来使用，而不缓存那些不常用且命中率低的数据缓存。因为命中率低，最后还是要在磁盘内查找,并不能有效提高性能。 MyBatis分为一级缓存和二级缓存，一级缓存是在SqlSession上的缓存，二级缓存是在SqlSessionFactory上的缓存，同时也可以配置关于缓存的设置。 二、一级缓存在程序运行过程中，我们可能会在一次数据库会话中执行完全相同的SQL语句，如果不停的访问数据库会影响运行效率，MyBatis提供的一级缓存优化了这一场景。 MyBatis一级缓存的生命周期和SqlSession一致。 MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上欠缺。 MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。 如果是相同的SQL语句，会优先命中一级缓存中的数据，而不会去访问数据库，执行过程如下： 每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。 1、测试：一级缓存有效查询数据库次数一级缓存的作用范围是会话级别，代码如下： public static void main(String[] args) { SqlSession session1 = MybatisUtils.getSqlSession(); // SqlSession session2 = MybatisUtils.getSqlSession(); // SqlSession session3 = MybatisUtils.getSqlSession(); try { UserMapper mapper1 = session1.getMapper(UserMapper.class); // UserMapper mapper2 = session2.getMapper(UserMapper.class); // ApartMapper mapper3 = session3.getMapper(ApartMapper.class); System.out.println(\"第一次读取\" + mapper1.findBid(1)); System.out.println(\"第二次读取\" + mapper1.findBid(1)); System.out.println(\"第三次读取\" + mapper1.findBid(1)); 执行结果： DEBUG 2022-04-13 10:57:13,302 demo.dao.UserMapper.findBid: ==> Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 10:57:13,332 demo.dao.UserMapper.findBid: ==> Parameters: 1(Integer) DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0 DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper.findByAid: ====> Parameters: 1(Integer) DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper.findByAid: Parameters: 物业部(String), 1(Integer) DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.update: Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.findByAid: ==> Parameters: 1(Integer) DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.findByAid: Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 11:21:26,779 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? SqlSession1读取：Emp{eid=1, ename='李四', gender='人事部', apart=Apart{did=1, dname='人事部'}} DEBUG 2022-04-13 11:21:26,781 org.apache.ibatis.transaction.jdbc.JdbcTransaction: DEBUG 2022-04-13 11:21:26,787 demo.dao.UserMapper.findBid: ==> Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 11:21:26,788 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 11:21:26,789 demo.dao.ApartMapper.findByAid: ====> Parameters: 1(Integer) DEBUG 2022-04-13 11:21:26,789 demo.dao.ApartMapper.findByAid: List&lt;E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException; protected abstract &lt;E> Cursor&lt;E> doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException; 在一级缓存的介绍中提到对Local Cache的查询和写入是在Executor内部完成的。在阅读BaseExecutor的代码后发现Local Cache是BaseExecutor内部的一个成员变量，如下代码所示。 public abstract class BaseExecutor implements Executor { protected ConcurrentLinkedQueue&lt;DeferredLoad> deferredLoads; protected PerpetualCache localCache; Cache： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示： 有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示： BaseExecutor成员变量之一的PerpetualCache，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示： public class PerpetualCache implements Cache { private String id; private Map&lt;Object, Object> cache = new HashMap&lt;Object, Object>(); 为执行和数据库的交互，首先需要初始化SqlSession，通过DefaultSqlSessionFactory开启SqlSession： private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) { ............ final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); } 在初始化SqlSesion时，会使用Configuration类创建一个全新的Executor，作为DefaultSqlSession构造函数的参数，创建Executor代码如下所示： public Executor newExecutor(Transaction transaction, ExecutorType executorType) { executorType = executorType == null ? defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Executor executor; if (ExecutorType.BATCH == executorType) { executor = new BatchExecutor(this, transaction); } else if (ExecutorType.REUSE == executorType) { executor = new ReuseExecutor(this, transaction); } else { executor = new SimpleExecutor(this, transaction); } if (cacheEnabled) { // 二级缓存开启，使用CahingExecutor装饰BaseExecutor的子类 executor = new CachingExecutor(executor); } executor = (Executor) interceptorChain.pluginAll(executor); return executor; } SqlSession创建完毕后，根据Statment的不同类型，会进入SqlSession的不同方法中，如果是Select语句的话，最后会执行到SqlSession的selectList，代码如下所示： @Override public &lt;E> List&lt;E> selectList(String statement, Object parameter, RowBounds rowBounds) { MappedStatement ms = configuration.getMappedStatement(statement); return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); } SqlSession把具体的查询职责委托给了Executor。如果只开启了一级缓存的话，首先会进入BaseExecutor的query方法。代码如下所示： @Override public &lt;E> List&lt;E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { BoundSql boundSql = ms.getBoundSql(parameter); CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql); } 在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示： CacheKey cacheKey = new CacheKey(); cacheKey.update(ms.getId()); cacheKey.update(rowBounds.getOffset()); cacheKey.update(rowBounds.getLimit()); cacheKey.update(boundSql.getSql()); cacheKey.update(value); //value是update的sql中带的参数 在上述的代码中，将MappedStatement的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构： private static final int DEFAULT_MULTIPLYER = 37; private static final int DEFAULT_HASHCODE = 17; private int multiplier; private int hashcode; private long checksum; private int count; private List&lt;Object> updateList; public CacheKey() { this.hashcode = DEFAULT_HASHCODE; this.multiplier = DEFAULT_MULTIPLYER; this.count = 0; this.updateList = new ArrayList&lt;Object>(); } 首先是成员变量和构造函数，有一个初始的hachcode和乘数，同时维护了一个内部的updatelist。在CacheKey的update方法中，会进行一个hashcode和checksum的计算，同时把传入的参数添加进updatelist中。如下代码所示： public void update(Object object) { int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object); } 同时重写了CacheKey的equals方法，代码如下所示： @Override public boolean equals(Object object) { ............. for (int i = 0; i &lt; updateList.size(); i++) { Object thisObject = updateList.get(i); Object thatObject = cacheKey.updateList.get(i); if (!ArrayUtil.equals(thisObject, thatObject)) { return false; } } return true; } 除去hashcode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL。 Statement Id + Offset + Limmit + Sql + Params BaseExecutor的query方法继续往下走，代码如下所示： list = resultHandler == null ? (List&lt;E>) localCache.getObject(key) : null; // 处理存储过程 if (list != null) { handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); } else { list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); } 如果查不到的话，就从数据库查，在queryFromDatabase中，会对localcache进行写入。 在query方法执行的最后，会判断一级缓存级别是否是STATEMENT级别，如果是的话，就清空缓存，这也就是STATEMENT级别的一级缓存无法共享localCache的原因。代码如下所示： if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) { clearLocalCache(); } 在源码分析的最后，我们确认一下，如果是insert/delete/update方法，缓存就会刷新的原因。 SqlSession的insert方法和delete方法，都会统一走update的流程，代码如下所示： @Override public int insert(String statement, Object parameter) { return update(statement, parameter); } @Override public int delete(String statement) { return update(statement, null); } update方法也是委托给了Executor执行。BaseExecutor的执行方法如下所示： @Override public int update(MappedStatement ms, Object parameter) throws SQLException { ErrorContext.instance().resource(ms.getResource()).activity(\"executing an update\").object(ms.getId()); if (closed) { throw new ExecutorException(\"Executor was closed.\"); } clearLocalCache(); return doUpdate(ms, parameter); } 每次执行update前都会清空localCache。 三、二级缓存MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。 MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。 在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。 1、配置在MyBatis主配置文件中开启二级缓存 cacheEnabled，默认为true。 记得实体类pojo要实现序列化接口，implements Serializable。 &lt;setting name=\"cacheEnabled\" value=\"true\"/> 在映射器XML文件中声明这个命名空间使用二级缓存。 &lt;cache/> &lt;!-- 参数详解： type：cache使用的类型，默认是PerpetualCache，这在一级缓存中提到过。 eviction： 定义回收的策略，常见的有FIFO，LRU。 flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。 size： 最多缓存对象的个数。 readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。 blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。 --> &lt;cache-ref namespace=\"mapper.StudentMapper\"/> &lt;!--cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。--> 2、测试：当事务操作未提交时，二级缓存是否有效开启两个SqlSession，运行但不进行commit()提交操作。 public static void main(String[] args) { SqlSession session1 = MybatisUtils.getSqlSession(); SqlSession session2 = MybatisUtils.getSqlSession(); try { UserMapper mapper1 = session1.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); System.out.println(mapper1.findBid(1)); System.out.println(mapper2.findBid(1)); 运行结果： DEBUG 2022-04-13 11:43:03,514 demo.dao.UserMapper.findBid: ==> Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 11:43:03,545 demo.dao.UserMapper.findBid: ==> Parameters: 1(Integer) DEBUG 2022-04-13 11:43:03,564 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0 DEBUG 2022-04-13 11:43:03,564 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 11:43:03,564 demo.dao.ApartMapper.findByAid: ====> Parameters: 1(Integer) DEBUG 2022-04-13 11:43:03,567 demo.dao.ApartMapper.findByAid: Parameters: 1(Integer) DEBUG 2022-04-13 11:43:03,575 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0 DEBUG 2022-04-13 11:43:03,575 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 11:43:03,575 demo.dao.ApartMapper.findByAid: ====> Parameters: 1(Integer) DEBUG 2022-04-13 11:43:03,576 demo.dao.ApartMapper.findByAid: Preparing: select did,dname from t_dep where did = ? emp1读取内容：Emp{eid=1, ename='李四', gender='人事部', apart=Apart{did=1, dname='人事部'}} DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.5 emp2读取内容：Emp{eid=1, ename='李四', gender='人事部', apart=Apart{did=1, dname='人事部'}} DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper.update: ==> Preparing: update t_emp set ename = ? where eid = ? DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper.update: ==> Parameters: 王麻子(String), 1(Integer) DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper.update: Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 12:33:40,060 demo.dao.UserMapper.findBid: ==> Parameters: 1(Integer) DEBUG 2022-04-13 12:33:40,060 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.5 DEBUG 2022-04-13 12:33:40,060 demo.dao.UserMapper.findBid: Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 12:47:38,889 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? emp1读取内容：Emp{eid=1, ename='王麻子', gender='人事部', apart=Apart{did=1, dname='人事部'}} DEBUG 2022-04-13 12:47:38,942 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.5 emp2读取内容：Emp{eid=1, ename='王麻子', gender='人事部', apart=Apart{did=1, dname='人事部'}} DEBUG 2022-04-13 12:47:38,945 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Opening JDBC Connection DEBUG 2022-04-13 12:47:38,948 demo.dao.ApartMapper.update: ==> Preparing: update t_dep set dname = ? where did = ? DEBUG 2022-04-13 12:47:38,948 demo.dao.ApartMapper.update: ==> Parameters: 物业部(String), 1(Integer) DEBUG 2022-04-13 12:47:38,950 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.6666666666666666 emp2读取内容：Emp{eid=1, ename='王麻子', gender='人事部', apart=Apart{did=1, dname='人事部'}} 由此可见，二级缓存有效，但是存在脏数据。 当sqlsession1的mapper1查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当sqlSession3的mapper3的update方法对class表进行更新时，update不属于Mapper2的namespace，所以Mapper2下的cache没有感应到变化，没有刷新缓存。当Mapper2中同样的查询再次发起时，从缓存中读取了脏数据。 5、测试：解决二级缓存脏数据问题在测试4的时候脏数据问题，经过多方查找资料，最终在美团大佬的文章中找到了我想要的答案， 可以使用Cache ref，让主查询引用子查询的命名空间，这样两个映射文件对应的SQL操作都使用的是同一块缓存了。 在被级联进行子查询的命名空间加入以下代码，让两个映射器对应的SQL操作都使用同一个缓存就ok了，此时进行更新操作就会强制刷新啦。 &lt;cache-ref namespace=\"这里是进行查询的那个命名空间接口的全限定类名\"/> 结果如下： DEBUG 2022-04-13 19:17:57,721 demo.dao.UserMapper.findBid: ==> Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 19:17:57,774 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 19:17:57,776 demo.dao.UserMapper.findBid: Preparing: update t_dep set dname = ? where did = ? DEBUG 2022-04-13 19:17:57,841 demo.dao.ApartMapper.update: ==> Parameters: 物业部(String), 1(Integer) DEBUG 2022-04-13 19:17:57,856 demo.dao.UserMapper.findBid: ==> Preparing: select eid,ename,gender,did from t_emp where eid = ? DEBUG 2022-04-13 19:17:57,858 demo.dao.ApartMapper.findByAid: ====> Preparing: select did,dname from t_dep where did = ? DEBUG 2022-04-13 19:17:57,862 demo.dao.UserMapper.findBid:","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://aloctw.github.io/tags/MyBatis/"},{"name":"缓存","slug":"缓存","permalink":"https://aloctw.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"MyBatis学习笔记(一)","slug":"MyBatis学习笔记-一","date":"2022-02-11T01:52:22.000Z","updated":"2022-07-20T11:56:45.034Z","comments":true,"path":"2022/02/11/MyBatis学习笔记-一/","link":"","permalink":"https://aloctw.github.io/2022/02/11/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"","text":"一、关于MyBatis&amp;emsp;&amp;emsp;持久层可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏（大部分的重要数据都会有相关的备份机制)，在断电或者其他情况下，重新开启系统仍然可以读取这些数据。 &amp;emsp;&amp;emsp; Mybatis 是一个优秀的持久层框架，它对 jdbc 的操作数据库的过程进行封装，使得开发者只需要专注 于 SQL 语句本身，而不用去关心注册驱动，创建 connection 等 Mybatis 通过 xml 文件配置或者注解的方式将要执行的各种 statement 配置起来，并通过 java 对象 和statement中的sql进行映射成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射成java 对象并返回。 &amp;emsp;&amp;emsp; 不屏蔽 SQL 意味着可以更为精确地定位 SQL 语句，可以对其进行优化和改造， 这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 &amp;emsp;&amp;emsp;并且它提供强大、灵活的映射机制 ，方便 Java 开发者使用 。提供动态 SQL 的功能，允许 我们根据不同条件组装 SQL ，这个功能远比其他工具或者 Java 编码的可读性和可维 护性高得多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要 求。 &amp;emsp;&amp;emsp;在MyBatis 中，提供了使用 Mapper 的接口编程，只要 个接口和 XML 就能创 建映射器，进一步简化我们的工作，使得很多框架 API MyBatis 中消失，开发者 能更集中于业务逻辑 。 二、MyBatis的核心组件&amp;emsp;&amp;emsp;MyBatis的核心组件分为四个部分： &amp;emsp;&amp;emsp;1.SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成SqlSessionFactory采用的是分布构建的Builder模式。 &amp;emsp;&amp;emsp;2.SqlSessionFactory (工厂接口)：依靠它来生成 SqlSession，使用的是工厂模式。 &amp;emsp;&amp;emsp;3.SqlSession（会话):一个既可以发送SQL执行返回结果，也可以获取 Mapper 的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis提供的SQL Mapper 接口编程技术，它能提高代码的可读性和可维护性。 &amp;emsp;&amp;emsp;4.SQL Mapper（映射器):MyBatis 新设计存在的组件，它由一个Java 接口和 XML文件（或注解）构成，需要给出对应的SQL 和映射规则。它负责发送SQL去执行,并返回结果。 三、使用XML构建SQLSessionFactory&amp;emsp;&amp;emsp;在MyBatis中的XML文件分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境；另一类是映射文件，它可以配置映射关系、SQL、参数等信息。 &amp;emsp;&amp;emsp;通常命名为MyBatis_config.xml,代码清单如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!-- 引入XML的约束文件，约束内容 --> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!--在jdbc.properties属性文件中配置数据库四要素--> &lt;properties resource=\"jdbc.properties\" /> &lt;!--设置全限定类名的别名--> &lt;typeAliases> &lt;package name=\"com.dyh.pojo\"/> &lt;/typeAliases> &lt;!--配置数据库连接--> &lt;environments default=\"dev\"> &lt;environment id=\"dev\"> &lt;transactionManager type=\"JDBC\"/> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"${mysql.Driver}\"/> &lt;property name=\"url\" value=\"${mysql.Url}\"/> &lt;property name=\"username\" value=\"${mysql.UserName}\"/> &lt;property name=\"password\" value=\"${mysql.UserPassword}\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--扫描映射器包--> &lt;mappers> &lt;package name=\"com.dyh.dao\"/> &lt;/mappers> &lt;/configuration> &amp;emsp;&amp;emsp;typeAlias元素：定义了一个别名role，它代表着com.learn.ssm.chapter3.pojo.Role这个类。这样定义后，在 MyBatis 上下文中就可以使用别名去代替全限定名了。&amp;emsp;&amp;emsp;environment元素：的定义，这里描述的是数据库。它里面的&lt;transactionManager&gt;元素是配置事务管理器，这里采用的是 MyBatis的JDBC管理器方式。然后采用&lt;dataSource&gt;元素配置数据库，其中属性 type&#x3D;”POOLED”代表采用MyBatis内部提供的连接池方式,最后定义一些关于JDBC的属性信息。&amp;emsp;&amp;emsp;mapper元素：代表引入的那些映射器，它里面的 package 属性会扫描整个包取到里面的所有映射器。 四、SQLSession&amp;emsp;&amp;emsp;在MyBatis 中, SqISession是其核心接口。在MyBatis中有两个实现类, DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager在多线程环境下使用。SqlSession的作用类似于一个 JDBC 中的 Connection对象，代表着一个连接资源的启用。具体而言，它的作用有3个：获取Mapper接口，发送SQL给数据库，控制数据库事务。 &amp;emsp;&amp;emsp;有了SqlSessionFactory创建SqlSession是非常简单的，注意SqlSession只是一个门面接口，真正执行业务语句的是底层的Executor！ package com.dyh.utlis; /** * ClassName: MybatisUtils * Package: com.dyh.utils * Description: 工具类：一个类中的所有方法都是静态方法，不需要实例化对象，所以私有化构造方法 * @Date: 2022/4/4 17:18 * @Author: shier */ public class MybatisUtils { private MybatisUtils() { } private static SqlSessionFactory sqlSessionFactory = null; public static synchronized SqlSessionFactory getSqlSessionFactory() { if(sqlSessionFactory != null) { return sqlSessionFactory; } try { InputStream is = Resources.getResourceAsStream(\"mybatis_config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); } catch (IOException e) { e.printStackTrace(); } return sqlSessionFactory; } public static SqlSession getSqlSession() { if(sqlSessionFactory == null) { getSqlSessionFactory(); } return sqlSessionFactory.openSession(); } } &amp;emsp;&amp;emsp;SqlSession控制数据库事务： package com.dyh.test; /** * ClassName: MainTest * Package: com.dyh.test * Description: * @Date: 2022/4/4 16:21 * @Author: shier */ public class MainTest { public static void main(String[] args) { SqlSession session = null; try { session = MybatisUtils.getSqlSession(); EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Employee employee = employeeMapper.getEmployee(1); System.out.println(employee); session.commit(); } catch (Exception ex) { if(session != null) { session.rollback(); // 回滚 } } finally { if(session != null) { session.close(); } } } } &amp;emsp;&amp;emsp;这里使用commit方法提交事务，或者使用rollback方法回滚事务。因为它代表着一个数据库的连接资源，使用后要及时关闭它，如果不关闭，那么数据库的连接资源就会很快被耗费光,整个系统就会陷入瘫痪状态，所以用finally语句保证其顺利关闭。&amp;emsp;&amp;emsp;由于SqlSession的获取 Mapper接口和发送SQL的功能需要先实现映射器的功能，而映射器接口也可以实现发送SQL 的功能。 五、映射器&amp;emsp;&amp;emsp;映射器是MyBatis中最重要也是最复杂的组件，它由一个接口和一个对应的XML文件组成。 &amp;emsp;&amp;emsp;它可以配置以下内容： &amp;emsp;&amp;emsp;描述映射规则 &amp;emsp;&amp;emsp;提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息 &amp;emsp;&amp;emsp;配置缓存 &amp;emsp;&amp;emsp;提供动态SQL 使用XML文件实现映射器定义一个映射器接口： public interface EmployeeMapper { Employee getEmployee(long id); } XML文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"demo.dao.ApartMapper\"> &lt;select id=\"getTask\" parameterType=\"long\" resultType=\"com.dyh.pojo.Task\"> select id,title,context,note from t_task where id = #{id} &lt;/select> &lt;/mapper> &amp;emsp;&amp;emsp;&lt;mapper&gt;元素中的属性namcspace 所对应的是一个接口的全限定名，于是 MyBatis上下文就可以通过它找到对应的接口。 &amp;emsp;&amp;emsp;&lt;select&gt;元素表明这是一条查询语句，而属性 id标识了这条 SQL，属性parameterType&#x3D;”long”说明传递给SQL的是一个long型的参数,而resultType&#x3D;”role”表示返回的是一个role类型的返回值。而role是之前配置文件 mybatis-config.xml配置的别名，指代的是com.learn.ssm.chapter3.pojo.Role。&amp;emsp;&amp;emsp;这条SQL 中的#{id}表示传递进去的参数。&amp;emsp;&amp;emsp;注意，我们并没有配置SQL执行后和 role的对应关系，它是如何映射的呢?其实这里采用的是一种被称为自动映射的功能，MyBatis在默认情况下提供自动映射，只要SQL返回的列名能和POJO对应起来即可。这里SQL返回的列名id和note是可以和之前定义的POJO的属性对应起来的,而表里的列role_name通过SQL别名的改写,使其成为roleName,也是和 POJO对应起来的，所以此时MyBatis就可以把SQL查询的结果通过自动映射的功能映射成为一个POJO。","categories":[],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://aloctw.github.io/tags/MyBatis/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://aloctw.github.io/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}]},{"title":"MySQL数据库基本操作","slug":"MySQL数据库基本操作","date":"2021-11-10T11:16:28.000Z","updated":"2022-07-14T12:06:16.000Z","comments":true,"path":"2021/11/10/MySQL数据库基本操作/","link":"","permalink":"https://aloctw.github.io/2021/11/10/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MySQL数据库之基本操作一、SQL分类SQL语言以功能分类： &amp;emsp;&amp;emsp;DDL（Data Definition Languages、数据定义语言）:这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。 &amp;emsp;&amp;emsp;DML（Data Manipulation Language、数据操作语言）:用于添加、删除、更新和查询数据库记 录，并检查数据完整性。 主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。 SELECT是SQL语言的基础，最为重要。 &amp;emsp;&amp;emsp;DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和 安全级别。 主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。 &amp;emsp;&amp;emsp;还有因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。 还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语 言）。 二、建库与建表&amp;emsp;&amp;emsp;建库： CREATE DATABASE 表名; &amp;emsp;&amp;emsp;建表： CREATE TABLE employee( 字段名陈 数据类型 [约束], --将emp_id设置为主键 emp_id INT PRIMARY KEY, emp_name VARCHAR(10) NOT NULL, emp_gender CHAR(4) NOT NULL, emp_age INT NOT NULL, emp_addr VARCHAR(20) NOT NULL, emp_mobile INT ); 三、增加数据的语法insert into 表名[(字段列表)] values(值列表); 情况一：给指定的表中所有字段添加数据 &amp;emsp;&amp;emsp;如果是主键且自动增长的列，可以不给该列显式赋值，也可以显式赋值：可以给自定义的值（不可以重复），也可以给null。 &amp;emsp;&amp;emsp;如果给表中的所有字段添加数据，数据列可以省略。 情况二： 给指定的表中部分字段添加数据 &amp;emsp;&amp;emsp;部分字段必须显式指定字段列表 不允许为空的字段必须要填的，允许为空的或者有默认值的、自动增长的字段可以不填。 &amp;emsp;&amp;emsp;如果指定的字段列表和值列表，字段列表和值列表只要一一对应，可以不和数据库中的列表顺序一致。 &amp;emsp;&amp;emsp;开发中: 即使在给所有字段添加数据时可以省略字段列表，但是建议显式给出你要添加的字段列表，可读性是很好的，而且SQL语句的性能要高。 四、主键与外键主键：&amp;emsp;&amp;emsp;在创建表时设置主键： CREATE TABLE employee( 字段名陈 数据类型 [约束], -- 1.将emp_id设置为主键 emp_id INT PRIMARY KEY, emp_name VARCHAR(10) NOT NULL, emp_gender CHAR(4) NOT NULL, emp_age INT NOT NULL, emp_addr VARCHAR(20) NOT NULL, emp_mobile INT -- 2.联合主键 PRIMARY KEY(emp_id,emp_name) ); 外键：【方式一】在创建表的时候进行添加 [CONSTRAINT symbol] FOREIGN KEY [id] (从表的字段1) REFERENCES tbl_name (主表的字段2) [ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION}] [ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION} 上面的代码是同一行，中括号里的内容是可选项。 解释如下： CONSTRAINT symbol：可以给这个外键约束起一个名字，有了名字，以后找到它就很方便了。如果不加此参数的话，系统会自动分配一个名字。 FOREIGN KEY：将从表中的字段1作为外键的字段。 REFERENCES：映射到主表的字段2。 ON DELETE后面的四个参数：代表的是当删除主表的记录时，所做的约定。 RESTRICT(限制)：如果你想删除的那个主表，它的下面有对应从表的记录，此主表将无法删除。 CASCADE(级联)：如果主表的记录删掉，则从表中相关联的记录都将被删掉。 SET NULL：将外键设置为空。 NO ACTION：什么都不做。 注：一般是RESTRICT和CASCADE用的最多。 【方式二】表已经创建好了，继续修改表的结构来添加外键。 ALTER TABLE employee ADD FOREIGN KEY(dept_id) REFERENCES department(id); 解释如下： ALTER TABLE employee：在从表employee中进行操作； ADD FOREIGN KEY(dept_id)：将从表的字段dept_id添加为外键； REFERENCES department(id)：映射到主表department当中为id的字段。 五、删除数据的语句delete from 表名 [where 条件]; 只删除表中的记录，不会删除表 truncate 表名; 将整张表删除，创建一个一模一样结构的新表 &amp;emsp;&amp;emsp;delete from 表名; 将表中的所有数据删除，从表中的数据中将符合条件的数据都过滤掉，使用[where 条件] 这是可选的，表示 where子句，可以设置的条件。 &amp;emsp;&amp;emsp;where子句可以用在delete、update、select中，where 结果表达式是一个布尔值。 &amp;emsp;&amp;emsp;比较运算符：&#x3D; 、!&#x3D;（&lt;&gt;）、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; &amp;emsp;&amp;emsp;如果在where 子句中，需要和null进行判断,不能使用 &#x3D; ！&#x3D; ,而是使用 is null或者is not null。 &amp;emsp;&amp;emsp;逻辑运算符:and逻辑与、or逻辑或、not逻辑非、between and 等价于 &gt;&#x3D; and &lt;&#x3D;。 -- 1.删除学号为10的学生信息 -- 执行流程：删除时 -- 从上往下一行行记录进行比较 delete from student where stu_id = 10 -- 2.删除年龄大于等于30的学生信息 delete from student where stu_age >= 30; -- 3.删除学生地址为湘潭大学的学生信息 delete from student where stu_addr = '湘潭大学'; -- 4.删除地址不为软件学院的学生信息 delete from student where stu_addr != '软件学院'; -- 5. 删除年龄在20~40之间学生信息 delete from student where stu_age >= 20 and stu_age &lt;= 40; -- 6.使用between and delete from student where stu_age between 20 and 40; -- 7.删除学号为13或手机号码为 -- 2222的学生信息 delete from student where stu_id = 13 or stu_mobile = 2222; -- 8.删除地址为null的学生信息 delete from student where stu_addr is null; -- 9.删除手机号不为空的学生信息 delete from student where stu_mobile is not null; 六、修改数据的语句update 表名 set 字段1=新值,... [where 条件]; -- 1.修改所有学生的地址 -- 为'中南大学' update student set stu_addr='中南大学' -- 2.修改学号为10的学生地址 -- 为上海大学 update student set stu_addr = '上海大学' where stu_id = 10; -- 修改多个字段 -- 修改学号5~10学生的 -- 地址为'南京大学'和 -- 手机号码为'080-1179' update student set stu_addr = '南京大学', stu_mobile = '080-1179' where stu_id between 5 and 10; update student set stu_addr = '北京大学' where stu_id % 2 = 0; 七、单表查询操作select 字段列表 from 表名 [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句] select 字段列表 from 表名; 如果查询所有字段可以*通配符 select 指定的字段 from 表名; 别名： 可以给结果集中的字段名称设置别名：select 字段名1 as 别名1, 字段名2 别名2… from 表名 where 子句： 从一组记录中筛选出符合条件的记录 -- 1.查询出所有学生所有信息 select stu_id, stu_name, stu_age, stu_mobile, stu_addr from student; select * from student; -- 2. 查询出所有学生指定的部分字段: 姓名和年龄 -- select语句查询出的结果称为结果集 -- select 除了可以查询出结果还是SQL语句的输出语句 select stu_name, stu_age from student; select stu_name as 学生姓名, stu_age 学生年龄 from student; -- 3.查询出学号在5~10学生姓名、手机号码信息 select stu_name as 姓名, stu_mobile as 手机号码 from student where stu_id >= 5 and stu_id &lt;= 10 -- 4. 查询出地址为中南大学或者 -- 南京大学学生信息 select * from student where stu_addr='中南大学' or stu_addr='南京大学';","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://aloctw.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://aloctw.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Go语言_初识Go语言","slug":"Go语言-初识Go语言","date":"2021-11-08T03:07:02.000Z","updated":"2022-07-14T12:05:56.000Z","comments":true,"path":"2021/11/08/Go语言-初识Go语言/","link":"","permalink":"https://aloctw.github.io/2021/11/08/Go%E8%AF%AD%E8%A8%80-%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/","excerpt":"","text":"Go语言_初识Go语言","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://aloctw.github.io/tags/Go/"},{"name":"Golang","slug":"Golang","permalink":"https://aloctw.github.io/tags/Golang/"}]},{"title":"Javascript_DOM操作","slug":"Javascript-DOM操作","date":"2021-10-18T00:37:56.000Z","updated":"2022-07-14T12:05:26.000Z","comments":true,"path":"2021/10/18/Javascript-DOM操作/","link":"","permalink":"https://aloctw.github.io/2021/10/18/Javascript-DOM%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Javascript_DOM操作一、关于Javascript与DOM1.JavaScriptJavaScript简称JS，是一种解释型脚本语言。 JavaScript是一种轻量级编程语言。 JavaScript是可插入HTML页面的编程代码。 JavaScript插入HTML页面后，基本上所有现代浏览器都可执行。 JavaScript预解析， js引擎会把js里面所有的var和function提升到当前作用域的最前面，所以非常神奇的是变量和函数可以先使用再声明。 &amp;emsp;&amp;emsp;她可由为网页添加各种样式的动态功能，为用户提供更流畅更美观的浏览效果，通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的 。 2.DOMDOM全称： Document Object Model （文本对象模型）。 &amp;emsp; 当网页被加载时，浏览器会创建页面的文档对象模型。是W3C推荐的处理可扩展标记语言（HTML和XML）的标准编程接口。DOM:对节点结构化表诉，并定义了一种方式可以使程序对该结构进行访问，将web页面和脚本语言连接起来。 &amp;emsp; 通过DOM接口可以改变网页的内容、结构和样式。 &amp;emsp; 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML： &amp;emsp; JavaScript 能够改变页面中的所有 HTML &amp;emsp; 元素 JavaScript 能够改变页面中的所有 HTML 属性 &amp;emsp; JavaScript 能够改变页面中的所有 CSS 样式 &amp;emsp; JavaScript 能够对页面中的所有事件做出反应 DOM是一种树状结构： document对象： &amp;emsp; 当浏览器载入HTML文档，她就会成为Document对象。 &amp;emsp; 而Document对象是HTML文档的根节点，使我们可以从脚本中对页面的所有元素进行访问，并且Document对象是Window对象的一部分，可以通过Window.document进行访问。 二、DOM操作查询常用操作： 方法 作用 document.getElementById() 返回对拥有指定 id 的第一个对象的引用。 document.getElementsByClassName() 返回文档中所有指定类名的元素集合，作为 NodeList 对象返回对拥有指定 id 的第一个对象的引用。 document.getElementsByTagName() 返回带有指定标签名的对象集合 document.getElementsByName() 返回带有指定名称的对象集合 案例： &amp;emsp; 以简单输入框模拟前端用户操作，以表格模拟后台数据处理。 &amp;emsp; 以JavaScript实现，对数据写入、删除、修改、隔行变色的操作。 &lt;!-- * @Author: yangzhihong * @Date: 2022-03-17 14:23:21 * @LastEditors: yangzhihong * @LastEditTime: 2022-03-18 10:43:17 * @FilePath: \\golang_coded:\\大云汉IT2021\\大云汉前端\\测试\\DOM节点操作（表单）.html * @Description: --> &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> 姓名：&lt;input type=\"text\" id=\"uname\">&lt;br> 年龄：&lt;input type=\"number\" id=\"age\" min=\"0\" max=\"150\">&lt;br> 手机号：&lt;input type=\"text\" id=\"mobile\">&lt;br> &lt;input type=\"button\" value=\"提交\" id=\"subBtn\"> &lt;hr> &lt;table id=\"users\" border=\"1\" cellpadding=\"5\" cellspacing=\"0\" width=\"70%\" align=\"center\"> &lt;tr> &lt;th>序号&lt;/th> &lt;th>姓名&lt;/th> &lt;th>年龄&lt;/th> &lt;th>手机号&lt;/th> &lt;th>操作&lt;/th> &lt;/tr> &lt;/table> &lt;script type=\"text/javascript\"> //定义一个数组 var users = [ { uname: '小刘', age: 23, mobile: '17670394021' }, { uname: '小杨', age: 20, mobile: '17670394021' }, { uname: '小周', age: 18, mobile: '17670394021' } ]; // 获取各个节点对象 var unameEle = document.querySelector('#uname'); var ageEle = document.querySelector('#age'); var mobileEle = document.querySelector('#mobile'); var subBtn = document.querySelector('#subBtn'); var userTable = document.querySelector('#users'); // 使用一个变量来记录初始值 // innerHTML是DOM的一个属性，可以获取到该对象元素的内容 var tableText = userTable.innerHTML; // 渲染，对表格内容进行初始化 renderTable(userTable, users); // 给按钮注册点击事件 subBtn.onclick = function() { // 获取到姓名、年龄、手机号 // 当点击提交按钮时对三个值进行操作 var uname = unameEle.value; var age = ageEle.value; var mobile = mobileEle.value; // 判断数据是否合法 if(uname == '' || uname == null) { alert('用户名不合法！'); return; } // 判断数据是否合法 if(age == '' || age == null) { alert('用户名不合法！'); return; } // 判断数据是否合法 if(mobile == '' || mobile == null) { alert('用户名不合法！'); return; } //使用正则表达式校验手机号 var mobileRegExp = /^1[345789]\\d{9}$/; if(!mobileRegExp.test(mobile)) { alert('您输入的手机号格式错误！') return; } // 事件，创建JS对象 var user = {}; user.uname = uname; user.age = age; user.mobile = mobile; // 将新增的对象添加到数组当中 users.push(user); // 清空填写表单数据 unameEle.value = ''; ageEle.value = ''; mobileEle.value = ''; // 对表格进行数据渲染 renderTable(userTable, users); // 弹窗提示 alert('提交成功！'); } // 渲染前端效果（将数组中的数据渲染到表格当中） function renderTable(ele,date) { if (ele == null) { alert('请传入一个节点对象'); } if (date == null || date.length == 0) { alert('请传入数组数据'); } // 将表格还原为最初状态 ele.innerHTML = tableText; // 循环数组 for (var index in date) { // 根据下标判断 // 1.创建新的tr行 var newTr = document.createElement('tr'); newTr.align = 'center'; // 根据下标奇偶性进行隔行变色 if (index % 2 == 0) { newTr.style = 'background-color: pink'; } // 将数组中的对象值传入前端tr行中 newTr.innerHTML = '&lt;td>'+index+'&lt;/td>&lt;td class=\"uname\">'+date[index].uname+'&lt;/td>&lt;td>'+date[index].age+'&lt;/td>&lt;td>'+date[index].mobile+'&lt;/td>&lt;td>&lt;a href=\"#\" onclick=\"delByIndex('+index+')\">删除&lt;/a>&lt;/td>'; // 2.将新tr追加到table中 ele.appendChild(newTr); } // 获取所有的用户名的td var tds = document.querySelectorAll('.uname'); // 给每个td绑定鼠标双击事件 for(var i=0; i&lt;tds.length; i++) { tds[i].ondblclick = function() { var uname = this.innerHTML; this.innerHTML = '&lt;input onblur=\"updateUname(event)\" type=\"text\" value=\"'+uname+'\">' } } } // 修改用户名的方法 function updateUname(event) { // 事件对象.target 属性获取数据源 var updateUname = event.target.value; // 获取父节点对象 var td = event.target.parentNode; td.innerHTML = updateUname; //获取焦点与失去焦点 var preTd = td.previousElementSibling; var index = parseInt(preTd.innerHTML); users[index].uname = updateUname; console.log(users); } function delByIndex(index) { // console.log(index); if(confirm('您确认要删除这个用户信息吗?')) { users.splice(index, 1); renderTable(userTable, users); } return false; } // 一个函数和一个节点的世界属性绑定在一起，而函数 // 定义在全局，函数的this是window，我如何获取到 // 这个事件的触发对象（事件源），函数被事件触发 // 因为js是基于事件驱动的，自动在事件触发时，将一个 // 事件对象传入给绑定的函数 &lt;/script> &lt;/body> &lt;/html>","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://aloctw.github.io/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://aloctw.github.io/tags/DOM/"},{"name":"HTML","slug":"HTML","permalink":"https://aloctw.github.io/tags/HTML/"}]},{"title":"Java多线程_线程优先级、线程安全与同步","slug":"Java多线程-线程优先级、线程安全与同步","date":"2021-10-01T00:57:25.000Z","updated":"2022-07-14T12:05:08.000Z","comments":true,"path":"2021/10/01/Java多线程-线程优先级、线程安全与同步/","link":"","permalink":"https://aloctw.github.io/2021/10/01/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%90%8C%E6%AD%A5/","excerpt":"","text":"Java多线程_线程优先级、线程安全与同步一、线程优先级与常用API&amp;emsp;&amp;emsp;每个线程执行时都有一定的优先级，优先级高的获取较多的执行机会，优先级低的线程则较少。线程默认的优先级与父线程优先级相同，Thread类提供了setPriority(int newPriority)、getPriority()方法来设置和返回指定线程的优先级，其中setPriority()方法的参数范围在1-10之间，也可以使用Thread类的三个常量(如下)，这三个静态常量来设置优先级可以保证程序会有更好的可移植性。 /** * The minimum priority that a thread can have. */ public final static int MIN_PRIORITY = 1; /** * The default priority that is assigned to a thread. */ public final static int NORM_PRIORITY = 5; /** * The maximum priority that a thread can have. */ public final static int MAX_PRIORITY = 10; 常用API有： int getPriority() : 返回线程的优先级 void setPriority() : 设置优先级 Thread.State getState() : 返回线程的当前状态 boolean isAlive() : 是否是活动状态 void setDaemon() : 设置线程为守护线程，当Java虚拟机退出时，所有的守护线程都终止 boolean isDaemon() : 判断当前线程是否是守护线程 void join() void join(long millis) static void sleep(long millis) : static void yield() : 相同点： 1.都是Thread类的静态方法。 2.进入同步代码块或方法，被监视器锁锁定的线程遇到这两个方法，都不会释放锁。 不同点： 1.sleep()方法将当前线程进入超时等待状态。 2.yield()方法不会改变当前线程的状态，都是Runnable状态，这个方法是让当前线程有可能从Running状态–&gt;Ready状态，也有可能不礼让，当前线程只会礼让给优先级高或者相同的其他Ready状态线程。 3、sleep()方法有声明InterruptedException异常，需要在编译期进行处理，yield()方法没有声明异常。 二、线程安全与同步2.1线程安全 当使用多个线程来访问同一个对象资源进行读写操作的时候，CPU的调度导致数据不一致，很容易出现线程安全问题。 售票系统演示线程安全问题： /** * ClassName: Demo6 * Package: PACKAGE_NAME * Description: * * @Date: 2022/3/1 10:43 * @Author: tancheng */ class TicketSys { private int K78 = 100; // 票的数量 // 售票方法 public void saleTicket() { // 判断余票数 if(K78 > 0) { // 取出K78中的数据进行判断 try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"抢到了第\" + (K78--) + \"张票\"); } } } // 携程网 class XieCheng extends Thread { private TicketSys ticketSys; public XieCheng() { } public XieCheng(TicketSys ticketSys, String name) { super(name); this.ticketSys = ticketSys; } public void run() { for(int i=0; i&lt;100; i++) { // 调用关联的系统售票 this.ticketSys.saleTicket(); } } } // 飞猪往 class FlyPig extends Thread { private TicketSys ticketSys; public FlyPig() { } public FlyPig(TicketSys ticketSys, String name) { super(name); this.ticketSys = ticketSys; } public void run() { for(int i=0; i&lt;100; i++) { // 调用关联的系统售票 this.ticketSys.saleTicket(); } } } public class Demo6 { public static void main(String[] args) { // 创建一个售票系统 TicketSys ts12306 = new TicketSys(); // 创建app XieCheng xc = new XieCheng(ts12306, \"携程\"); FlyPig fp = new FlyPig(ts12306, \"飞猪\"); xc.start(); fp.start(); } } 结构如图： 2.2解决线程安全问题方式（线程同步） 解决线程的安全问题相对的会降低程序的运行效率，为了减少这种负面影响，建议只对需要进行修改操作的方法进行同步，单线程环境中不需要考虑线程安全，只在多线程环境中使用同步。 2.2.1同步代码块 采用Java多线程的synchronized关键字来声明同步代码块，使用同步监视器锁来解决。语法如下： synchronized(监视器锁) { 同步代码块 } 作用：被同一个监视器锁监视的代码块，一次只能让一个线程进入，进入的线程持有这个监视器锁，其他线程没有这个锁是进入不了同步代码块，其他线程就进入阻塞（blocked）状态，只有当持有同步锁的线程释放锁后，其他线程才会去争夺锁。 2.2.2同步方法 与同步代码块相对应，Java多线程还提供了同步方法，使用synchronized关键字来修饰某个方法，该方法则为同步方法。 对于synchronized修饰的实例方法（非static方法）来说，默认的同步锁对象是this，也就是调用该方法的对象，同步静态方法时默认的同步锁对象是当前字节码对象 。 被同步监视器锁锁定的线程何时释放锁： ①.从同步代码块、同步方法出来时释放锁 ②.遇到break,return ③. 遇到未处理的异常 ④.遇到wait()方法释放锁，获得同步锁的线程进入waiting() 2.2.3同步锁 &amp;emsp;&amp;emsp;从Java5开始提供了一种更强大的线程同步方式——Lock接口。Lock中的实现类ReentrantLock(可重入锁)，使用Lock()加锁、unLock()解锁，因为需要手动控制来释放锁资源，所以需要在使用try&#x2F;catch解决异常时将unLock()方法放到finally里面释放锁资源。 package com.Demo; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class TestLock { private Lock lock = new ReentrantLock(); public static void main(String[] args) { final TestLock testLock = new TestLock(); new Thread() { @Override public void run() { testLock.insert(Thread.currentThread()); } }.start(); new Thread() { @Override public void run() { testLock.insert(Thread.currentThread()); } }.start(); } public void insert(Thread thread) { lock.lock(); try { System.out.println(thread.getName()+\"得到了锁\"); } catch (Exception e) { // TODO: handle exception }finally { System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); } } } 其中还有个ReadWriteLock()方法，称为读写锁。可以让只需要读取功能的线程进入，将需要修改功能的线程阻塞在外面，但需要修改功能的线程只能有一个获取锁。意味着不再是只能有一个线程获取锁，更加在保证安全的同时提高程序运行的效率。 public interface ReadWriteLock { /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock(); }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://aloctw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程安全","slug":"线程安全","permalink":"https://aloctw.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"}]},{"title":"Java多线程_线程的生命周期与6种状态","slug":"Java多线程-线程的生命周期与6种状态","date":"2021-09-25T02:20:14.000Z","updated":"2022-07-14T12:04:50.000Z","comments":true,"path":"2021/09/25/Java多线程-线程的生命周期与6种状态/","link":"","permalink":"https://aloctw.github.io/2021/09/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E6%E7%A7%8D%E7%8A%B6%E6%80%81/","excerpt":"","text":"Java多线程_线程的生命周期与6种状态一、线程的生命周期&amp;emsp;&amp;emsp;当线程被创建并启动之后，并不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中要经过：新建(NEW)、运行(RUNNABLE)、阻塞(BLOCKED)、永久等待(WAITING)、超时等待(WIME_WAITING)、终止(TERMINATED)。 &amp;emsp;&amp;emsp;当线程被启动的时候，它并不可能一直独占CPU运行，所以CPU是一直在多条线程之间来回切换运行，于是线程也是不停在运行 与 就绪之间进行切换。 &amp;emsp; &amp;emsp;Java源码中有提到： public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul> * &lt;li>{@link Object#wait() Object.wait} with no timeout&lt;/li> * &lt;li>{@link #join() Thread.join} with no timeout&lt;/li> * &lt;li>{@link LockSupport#park() LockSupport.park}&lt;/li> * &lt;/ul> * * &lt;p>A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt>Object.wait()&lt;/tt> * on an object is waiting for another thread to call * &lt;tt>Object.notify()&lt;/tt> or &lt;tt>Object.notifyAll()&lt;/tt> on * that object. A thread that has called &lt;tt>Thread.join()&lt;/tt> * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul> * &lt;li>{@link #sleep Thread.sleep}&lt;/li> * &lt;li>{@link Object#wait(long) Object.wait} with timeout&lt;/li> * &lt;li>{@link #join(long) Thread.join} with timeout&lt;/li> * &lt;li>{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li> * &lt;li>{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li> * &lt;/ul> */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } 二、线程的主要状态1、新建状态(NEW)：&amp;emsp;&amp;emsp;实现Runnable接口和继承Thread可以得到一个线程类，使用new关键字创建了一个程序之后，改线程就处于新建状态，此时的线程和其他Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化成员变量的值。 &amp;emsp;&amp;emsp;当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了，至于何时开始取决于CPU调度器的调度。 &amp;emsp;&amp;emsp;注意：启动线程使用方法start()，而不是run()方法！永远不要直接调用线程对象的run()方法！当调用start()方法后，系统会将该对象的run()方法作为程序执行体来处理；如果直接调用对象的run()方法，系统会将线程对象当做一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。 2、运行状态(RUNNABLE):&amp;emsp;&amp;emsp;在线程的运行状态中也可分为两个小状态：运行中状态(Running)、就绪状态(Ready)。当处于就绪状态的线程获得了CPU，将会开始执行run()方法的线程执行体，则该线程处于运行中状态。 &amp;emsp;&amp;emsp;Ready(就绪状态)： 等待调度器调度 &amp;emsp;&amp;emsp;Running（运行中状态）： 被调度器（scheduler）选中，CPU正在执行 &amp;emsp;&amp;emsp;Ready —-&gt; 调度器选中 —-&gt; Running &amp;emsp;&amp;emsp;Running —-&gt; 调度器切换 | Thread.yeild() 方法—&gt; Ready 3、永久等待状态(WAITING):&amp;emsp;&amp;emsp;当调用wait()方法或join()方法此时的线程将退出运行状态，进入永久等待状态，除非使用notify()方法或notifyAll()方法主动唤醒，否则永久等待。 &amp;emsp;&amp;emsp;进入永久等待状态： &amp;emsp;&amp;emsp;Runnable –&gt; wait()方法 | join() 方法 —-&gt; Waiting &amp;emsp;&amp;emsp;退出永久等待状态： &amp;emsp;&amp;emsp;Waiting -&gt; notify()方法 | notifyAll() —-&gt; Runnable 4、超时等待状态(TIMED_WAITING)：&amp;emsp;&amp;emsp;当调用sleep(long millis)、wait(long millis)、join(long millis)这三个方法时，线程将进入超时等待状态，等待设定时间long millis结束或使用notify()或notifyAll()对其主动唤醒退出超时等待状态，进入到运行就绪状态等待CPU调度分配资源。 &amp;emsp;&amp;emsp;进入超时等待状态： &amp;emsp;&amp;emsp;Runnable –&gt; sleep(long millis) | wait(long millis) | join(long millis) —&gt; Timed_Waiting &amp;emsp;&amp;emsp;超时等待状态： &amp;emsp;&amp;emsp;Timed_Waiting –&gt; 设置时间结束 | notify() | notifyAll() –&gt; Runnable 5、阻塞状态(BLOCKED)：&amp;emsp;&amp;emsp;阻塞状态是被监视器锁监视的线程， 被同步锁或者IO锁阻塞 ,线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态 。为了线程的安全，使用synchronized关键字给线程上锁，使得多个线程能够有秩序的进入同步代码块获取权限。 &amp;emsp;&amp;emsp;进入阻塞状态： &amp;emsp;&amp;emsp;Runnable —&gt; 没有获取锁 —-&gt; 阻塞 &amp;emsp;&amp;emsp;退出阻塞状态： &amp;emsp;&amp;emsp;阻塞 —&gt; 获取锁对象 —&gt; Runnable 6、终止状态(TERMINATED):&amp;emsp;&amp;emsp;线程终止状态也称为线程死亡，有三种方式进入该状态： &amp;emsp;&amp;emsp;①run()或call()方法执行完成，线程正常结束。 &amp;emsp;&amp;emsp;②线程抛出一个未捕获的Exception或Error。 &amp;emsp;&amp;emsp;③直接调用该线程的stop()方法来结束该线程—-该方法容易死锁，不建议使用。 &amp;emsp;&amp;emsp;Runnable —-&gt; 任务方法执行完毕|发生异常 —&gt; Terminated &amp;emsp;&amp;emsp;线程对象的isAlive()方法可以返回线程的状态，当处于就绪、运行、等待、阻塞状态返回true，新建、死亡返回false。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://aloctw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java多线程_创建线程的多种方式","slug":"Java多线程-创建线程的多种方式","date":"2021-09-22T11:02:15.000Z","updated":"2022-07-14T12:04:34.000Z","comments":true,"path":"2021/09/22/Java多线程-创建线程的多种方式/","link":"","permalink":"https://aloctw.github.io/2021/09/22/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Java多线程_创建线程的多种方式一、线程与进程​ 几乎所有的操作系统都支持进程的概念，所有运行中的任务都对应一个进程(Process)。当一个程序进入内存运行时，即变成一个进程。进程是处于运行中的程序，并且具有一定的独立功能，进程是系统进行资源调度的一个独立单位。 ​ 一般而言，进程包含三个特征：独立性、动态性、并发性。 ​ 一个程序运行后至少会有一个进程，一个进程可以包含多个线程，但至少要有个线程。 ​ 归纳起来就是说：操作系统可以同时执行多个任务，每个任务就是进程；进程可以同时执行多个任务，每个任务就是线程。 温馨提示（并发性与并行性）：​ 并发性(concurrency)和并行性(parallel)是两个概念，并行是指在同一时刻，有多条指令在多个处理器上同时执行；并发是指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程被同时执行的效果。 二、多线程的优势​ 线程在程序中是独立的、并发的执行流，与分隔的进程相比，线程分隔程度要小很多。当操作系统创建一个进程时，必须为该进程分配独立的内存空间，并分配大量的相关资源；但创建线程则简单很多，因此使用多线程来实现并发比使用多进程实现并发要强很多。 ​ 1、进程之间不能共享内存，但线程之间共享内存非常容易， ​ 2、系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价要小很多，因此使用多线程实现多任务并发要比进程效率高很多。 ​ 3、Java语言内置了多线程功能支持，而不是单纯的作为底层操作系统的调度模式，从而简化了Java的多线程编程。 三、线程的创建和启动​ Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例，以下则介绍其中三种常见创建线程对象的方法。 1、继承Thread类创建线程类​ 创建步骤： ​ ①定义Thread类的子类，并重写该类的run()方法，该run()方法体就代表了线程需要完成的任务。因此吧run()方法称为线程执行体。 ​ ②创建Thread子类的实例，即创建了线程对象。 ​ ③调用线程对象的start()方法来启动该线程。 /** * @program: code * @description: 通过继承Thread类创建线程对象 * @author: yangzhihong * @create: 2022-02-28 20:29 **/ public class Thread_jc extends Thread { private int i; //重写run()方法，run()方法的方法体就是线程执行体。 public void run(){ for (i = 0; i &lt; 100; i++) { //d当线程类继承Thread类时，直接使用this即可获取当前线程 //Thread对象的getName()返回当前线程的名字 //因此可以直接调用getName()方法返回当前线程的名字 System.out.println(\"我是子线程\" + getName() + \"\" + i); } } public static void main(String[] args){ for (int i = 0; i &lt; 100; i++) { //调用Thread的currentThread()方法获取当前线程 System.out.println(\"我是主线程\" + Thread.currentThread().getName() + \"\" + i); if (i == 20) { //创建并启动第一个线程 new Thread_jc().start(); //创建并启动第二个线程 new Thread_jc().start(); } } } } Thread类提供了常用的API Thread.currentThread() ： 静态方法用于获取当前的线程对象。 getName() : 可以获取线程对象的名称。 ​ 主线程的名称默认是main，不能修改。 ​ 子线程的名称默认是 Thread-0,……. ​ 可以修改，修改方式，可以提供有参构造方法，调用父类的有参构造方法Thread(String name) ​ 也可以使用setName(String name) 设置线程名称。 2、实现Runnable接口创建线程​ 自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象。 ​ 创建步骤： ​ ①定义Runnable接口的实现类，并重写该方法的run()方法，该run()方法的方法体同样是该线程的线程执行体。 ​ ②创建Runnable实现类的实例，并以此作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 ​ ③调用线程线程对象的start()方法来启动线程。 ​ **注意：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是Thread线程负责执行其target的run()方法。4 /** * @program: code * @description: 实现Runnable接口创建线程对象 * @author: yangzhihong * @create: 2022-03-01 10:24 **/ // 自定义一个任务类 class MyTask implements Runnable { @Override public void run() { for(int i=1; i&lt;=100; i++) { System.out.println(Thread.currentThread().getName() + \"----\" + \"刷出第\" + i + \"个小怪\"); } } } public class RunnableThread { public static void main(String[] args) { // 创建任务对象 MyTask myTask = new MyTask(); // 创建线程对象 Thread thread = new Thread(myTask, \"子线程\"); // 开启子线程对象的任务 thread.start(); for(int j=1; j&lt;=100; j++) { System.out.println(Thread.currentThread().getName() + \"----\" + \"刷出第\" + j + \"个大BOSS\"); } } } 3、使用Callable和Future创建线程​ 从Java5 开始，Java提供了Callable接口，该接口与Runnable接口非常相似，Callable接口提供了一个call()方法可以作为线程执行体，但call()方法比run()方法功能更强大：可以有返回值、可以声明抛出异常。 ​ Java5 提供了一个与Callable配套的Future接口，Future有个实现类FutureTask，该类的RunnableFuture接口对Future、Runnable都进行了实现。可以作为中介来关联Runnable与Future，并通过Future的公共方法V get() 获取到Callable的返回值，于是乎Callable对象就可以作为Thread的target来创建线程了。（V get()方法中的V是表示泛型，表示Callable接口里的类型必须与call()返回值类型相同） ​ 创建步骤： ​ ①创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且该call()方法有返回值，再创建Callable实现类的实例对象。从Java8 开始可以直接使用Lambda表达式创建Callable对象。 ​ ②使用FutureTask类包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 ​ ③使用FutureTask对象作为Thread对象的target创建并启动新线程。 ​ ④调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /** * @program: code * @description: 通过Callable与Future来创建线程对象 * @author: yangzhihong * @create: 2022-03-01 11:56 **/ // 实现了Callable接口的类，也是一个任务类 class MyCall implements Callable&lt;Integer> { @Override public Integer call() throws Exception { int sum = 0; for(int i=1; i&lt;=100; i++) { sum += i; } return sum; } } public class CallableFutureThread { public static void main(String[] args) throws ExecutionException, InterruptedException { // 创建任务对象 MyCall myCall = new MyCall(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 // 在构造FutureTask对象时，可以通过构造方法将Callable接口的 // 实现对象传入 FutureTask&lt;Integer> futureTask = new FutureTask&lt;>(myCall); // 创建一个线程对象 Thread thread = new Thread(futureTask); thread.start(); // 通过get()方法来获取Callable任务方法的返回结果 if(futureTask.isDone()) { Integer result = futureTask.get(); System.out.println(result); } } } 4、这三种创建线程方式的对比​ 通过继承Thread类和实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值和可以声明抛出异常，因此可以将Runnable和Callable归为同一种实现接口方式。 ​ 实现接口方式创建线程优缺点： ​ ①线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 ​ ②在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源，从而可以将CPU、代码和数据分开。形成清晰的模型。较好的体现了面向对象的思想。 ​ ③缺点，编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread()方法。 ​ 采用继承Thread类方式创建线程优缺点： ​ ①缺点，因为线程类已经继承了Thread类，所以不能再继承其他父类。 ​ ②优点，编写简单，如果需要访问当前线程，则不需要使用Thread.currentThread()方法，直接this即可获得当前线程。 ​ 因此一般推荐采用实现Runnable接口、Callable接口方式来创建多线程。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://aloctw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java_数据传输之自写字节缓冲流，输入流，输出流","slug":"Java_数据传输之自写字节缓冲流，输入流，输出流","date":"2021-09-20T07:41:08.000Z","updated":"2022-07-14T12:04:16.000Z","comments":true,"path":"2021/09/20/Java_数据传输之自写字节缓冲流，输入流，输出流/","link":"","permalink":"https://aloctw.github.io/2021/09/20/Java_%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B9%8B%E8%87%AA%E5%86%99%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%8C%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%8C%E8%BE%93%E5%87%BA%E6%B5%81/","excerpt":"","text":"Java_数据传输之自写字节缓冲流一、字节缓冲输出流​ java.io.BufferedOutputStream extends OutputStream ​ BufferedOutputStream：字节缓冲输出流。 继承自父类的共性成员方法：​ public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 ​ public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 ​ public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 ​ public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 ​ public abstract void write(int b) ：将指定的字节输出流。 构造方法：​ BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 ​ BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 参数： ​ OutputStream out：字节输出流，可以传递 FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率 ​ int size：指定缓冲流内部缓冲区的大小，不指定默认。 使用步骤【重要】​ ① 创建FileOutputStream对象,构造方法中绑定要输出的目的地 ​ ② 创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 ​ ③ 使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 ​ ④ 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 ​ ⑤ 释放资源(会先调用flush方法刷新数据) /** * @program: code * @description: 字节缓冲输出流 * @author: yangzhihong * @create: 2022-02-24 11:30 **/ public static void main(String[] args) throwsIOException { //1.创建FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(\"E:\\\\a.txt\"); //2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 BufferedOutputStream bos = newBufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 bos.write(\"我把数据写入到内部缓冲区中\".getBytes()); //4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 bos.flush(); //5.释放资源(会先调用flush方法刷新数据,第4部可以省略) bos.close(); } 二、字节缓冲输入流​ java.io.BufferedInputStream extends InputStream ​ BufferedInputStream:字节缓冲输入流 继承自父类的成员方法：​ int read()从输入流中读取数据的下一个字节。 ​ int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 ​ void close() 关闭此输入流并释放与该流关联的所有系统资源。 构造方法：​ BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 ​ BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 参数： ​ InputStream in：字节输入流，可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率 ​ int size：指定缓冲流内部缓冲区的大小，不指定默认。 使用步骤【重要】：​ ① 创建FileInputStream对象,构造方法中绑定要读取的数据源 ​ ② 创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 ​ ③ 使用BufferedInputStream对象中的方法read,读取文件 ​ ④ 释放资源 /** * @program: code * @description: 字节缓冲输入流 * @author: yangzhihong * @create: 2022-02-24 11:40 **/ public static void main(String[] args) throwsIOException { //1.创建FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"10_IO\\\\a.txt\"); //2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 BufferedInputStream bis = newBufferedInputStream(fis); //3.使用BufferedInputStream对象中的方法read,读取文件 //int read()从输入流中读取数据的下一个字节。 /*int len = 0;//记录每次读取到的字节*/ while((len = bis.read())!=-1){ System.out.println(len); } //int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 byte[] bytes =new byte[1024];//存储每次读取的数据 int len = 0; //记录每次读取的有效字节个数 while((len = bis.read(bytes))!=-1){ System.out.println(new String(bytes,0,len)); } //4.释放资源 bis.close(); } 三、自写字节缓冲流1、通过自写缓冲流更加理解数据在流中传输的底层原理 2、不止是需要会用，更加需要去充分理解，让每一行代码化繁为简 import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; /** * @program: code * @description: 自写装饰设计模式（增强字节输出节点流写入数据的性能） * @author: yangzhihong * @create: 2022-02-24 14:45 **/ class MyBufferedOutputStream{ //成员属性 private OutputStream out; //定义缓冲区大小 private static final int DEFAULT_BUFFER_SIZE = 8192; //定义字节数组 private byte[] buf_array; //定义下标index private int index = 0; //构造方法，创建字节数组对象，并将传来的数据长度赋给该对象 private MyBufferedOutputStream(int bufSize){ this.buf_array = new byte[bufSize]; } //构造方法，将传过来的字节输出流进行处理 public MyBufferedOutputStream(OutputStream out){ this(DEFAULT_BUFFER_SIZE); this.out = out; } //构造方法，将传过来的路径字符串进行处理 public MyBufferedOutputStream(String filePath) throws FileNotFoundException { this(DEFAULT_BUFFER_SIZE); this.out = new FileOutputStream(filePath); } //创建write()写入方法，并移动字节数组下标 public void write(int date){ this.buf_array[index++] = (byte) date; } //创建flush()刷新方法，对缓冲区进行刷新，将缓冲区内数据写入进文件 public void flush() throws IOException { this.out.write(this.buf_array,0,index); } // 创建close()方法关闭流，实际上也是调用了flush()方法 // 也是在这一步字节输出流才将数据写入目标文件 public void close(){ try { flush(); // 刷新缓冲区 this.out.close(); } catch (IOException e) { e.printStackTrace(); } } } public class MyBuffereddOutputStreamDemo { // 程序入口，测试自写字节缓冲流 public static void main(String[] args) throws IOException { // 创建输出流对象，如果没有目标文件将会自动创建目标文件 OutputStream outputStream = new FileOutputStream(\"C:\\\\Users\\\\yang\\\\Desktop\\\\yangsir.txt\"); // 使用自写字节缓冲流将输出流进行包装（套管子） MyBufferedOutputStream myBufferedOutputStream = new MyBufferedOutputStream(outputStream); // 测试 myBufferedOutputStream.write(97); myBufferedOutputStream.write(98); // 关闭流，防止内存占用过多 myBufferedOutputStream.close(); } }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"https://aloctw.github.io/tags/IO%E6%B5%81/"},{"name":"字节缓冲流","slug":"字节缓冲流","permalink":"https://aloctw.github.io/tags/%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81/"}]},{"title":"函数（方法）、递归","slug":"函数（方法）、递归","date":"2021-09-16T10:27:57.000Z","updated":"2022-07-14T12:03:52.000Z","comments":true,"path":"2021/09/16/函数（方法）、递归/","link":"","permalink":"https://aloctw.github.io/2021/09/16/%E5%87%BD%E6%95%B0%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89%E3%80%81%E9%80%92%E5%BD%92/","excerpt":"","text":"函数（方法）与递归妙用一、函数&amp;emsp;1、函数的作用：​ 封装代码逻辑，将某个业务功能的整体实现放到一起，以方便其他程序员调用，实现代码复用，减少代码冗余。 &amp;emsp;2、函数的使用：​ ①、函数声明四要素：修饰符 返回值 方法名 (参数列表){方法体}。 public 公共的、谁都可以调用；static 静态的，通过类名调用。 ​ ②、返回值：是八大基本数据类型（byte、short、int、long、float、double、char、boolean、String），还可以是void（void表示没有返回值）。 ​ ③、执行过程中，将实际参数的值复制一份给形式参数与执行，如果有返回值，函数执行完毕后将返回值赋值给接收变量。 &amp;emsp;3、注意事项：​ ①、如果返回值为void，则函数体内可以没有return。 ​ ②、如果返回值是其他类型，方法体内必须要有return，而且return后面要跟一个变量、表达式、或值，而且他们的类型要与函数声明的返回值一致，若不一致，要么可以自动提升数据类型，要么在函数体内进行强制转换。 ​ ③、如举例： public static int max(short num1,short num2){ return num1 > num2 ? num1 : num2; } 二、递归1、什么是递归？​ 函数体内调用自身函数 2、递归在什么地方使用？​ ①、某些数学问题（猴子粉桃、阶乘） ​ ②、IO流遍历文件夹以及子文件夹 ​ ③、循环显示某些菜单的时候 3、递归的使用？​ ①、边界条件（初识状态），最简单的一种状态，递归终止的条件。 ​ ②、递推公式，相邻两项之间的关系。 ​ ③、注意：当递归调用次数比较多的时候，占用内存和系统资源会非常大，所以在企业开发中能不用递归尽量不用递归！！ 三、案例​ 1、猴子分桃，有一堆桃子，第一天，某只猴子偷吃了一半多一颗，第二天又有某只猴子偷吃了剩下的桃子中的一半多 一颗，……，等到第7天的时候，有只猴子发现只剩下一只桃子了，问这堆桃子最开始有多少颗？ ​ 类比递推公式：An&#x3D;An-1+2， A1&#x3D;1 1 3 5 7 9 package day09; /** * @fileName : tao.java * @description : TODO * @author : yangzhihong * @date : 2021年12月23日-下午4:05:57 */ public class tao { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月23日下午4:05:57 */ public static void main(String[] args) { System.out.println(f(1)); } public static int f(int n) { if(n == 7) { // ① 最简单的状态 return 1; }else { // ② 递推公式 return 2*(f(n+1)+1); // 函数体内调用自身函数 // n=6 = 2*(f(7)+1) // n=5 = 2*[f(6)+1] = 2*[2*(f(5)+1)+1] // n=4 = 2*[f(5)+1] // n=3 = 2*[f(4)+1] // n=2 = 2*[f(3)+1] // n=1 = 2*[f(2)+1] = 2*[2*(f(3)+1)+1] // 内存占用会非常多，尤其调用次数比较多的时候 // 在企业开发中，能不用递归尽量不用！！ } } } ​ 2、循环显示菜单 package day09; import java.util.Scanner; /** * @fileName : tao.java * @description : TODO * @author : yangzhihong * @date : 2021年12月23日-下午4:05:57 */ public class tao { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月23日下午4:05:57 */ public static void main(String[] args) { menu(); } public static void menu() { Scanner scanner = new Scanner(System.in); System.out.println(\"=========【打印图形系统】=======\"); System.out.println(\"--- 1、打印直角三角形 printRt()\"); System.out.println(\"--- 2、打印等腰三角形 printDY()\"); System.out.println(\"--- 3、打印菱形 printLX\"); System.out.println(\"--- 4 退出系统\"); // 接收用户输入的选择，然后进行判断 int choise = scanner.nextInt(); switch (choise) { case 1:System.out.println(\"直角三角形\");break; case 2:System.out.println(\"等腰三角形\");break; case 3:System.out.println(\"菱形\");break; case 4:System.exit(0); default:break; } menu();// 递归调用，方法体内调用自身方法 } } ​ 3、递归求阶乘 a ! &#x3D; ? package day09; import java.util.Scanner; /** * @fileName : tao.java * @description : TODO * @author : yangzhihong * @date : 2021年12月23日-下午4:05:57 */ public class tao { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月23日下午4:05:57 */ public static void main(String[] args) { System.out.println(jc(7)); } public static long jc(int n) { if (n == 1) { return 1; } return n * jc(n-1); // 递归调用 } }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"函数方法","slug":"函数方法","permalink":"https://aloctw.github.io/tags/%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"https://aloctw.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"Java基本功之for循环","slug":"Java基本功之for循环","date":"2021-09-15T10:16:26.000Z","updated":"2022-07-14T12:03:36.000Z","comments":true,"path":"2021/09/15/Java基本功之for循环/","link":"","permalink":"https://aloctw.github.io/2021/09/15/Java%E5%9F%BA%E6%9C%AC%E5%8A%9F%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"八个for循环运用小案例一、for循环语法： for(初始化; 布尔表达式; 更新) &#123; // 代码语句 &#125; ​ 1.最先执行初始化步骤，可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句​ 2.然后，检测布尔表达式的值：如果为 true，循环体被执行；如果为 false，循环终止，开始执行循环体后面的语句 ​ 3.执行一次循环后，更新循环控制变量 ​ 4.再次检测布尔表达式，循环执行上面的过程 二、循环三要素​ 1.循环初始化；2.循环条件；3.循环变量的修改。 三、for循环测试​ 1.有个人想知道，一年之内一对新生兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，每对兔子从出生后第3个月起每月生一对小兔子。 ​ 假如一年内没有发生死亡现象，那么，一对兔子一年内(12 个月)能繁殖成多少对？ package day06; /** * @fileName : day06_Demo1.java * @description : TODO * @author : yangzhihong * @date : 2021年12月18日-下午2:13:14 */ public class day06_Demo1 { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月18日下午2:13:14 */ public static void main(String[] args) { day06_Demo1.rabbitTest1(); } private static void rabbitTest1() { int sum = 0; int tu1 = 1,tu2 = 1;//tu1是第一个月的兔子数，tu2是第二个月的兔子数 for(int a=3;a&lt;=12;a++) { sum = tu1 + tu2; System.out.println(sum); tu2 = tu1; tu1 = sum; } System.out.println(\"第12个月的月末兔子的数量 为: \"+sum+\"对\"); } } ​ 2.计算出1–100之间所有不能被3整除的整数的和大于(或等于)2000的数字。 package day06; import java.util.Iterator; /** * @fileName : day06_Demo2.java * @description : TODO * @author : yangzhihong * @date : 2021年12月18日-下午3:15:51 */ public class day06_Demo2 { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月18日下午3:15:51 */ public static void main(String[] args) { int sum = 0; for (int i = 1; i &lt;= 100;i++) { if (i % 3 ==0) { continue; } sum += i; if (sum >= 2000) { System.out.println(\"这个数是：\" + sum); break; } } } } ​ 3.求s&#x3D;a+aa+aaa+aaaa+…+a…a的值，其中a是一个数字。例如2+22+222+2222, a的值和加数个数n均从键盘获取。 package day06; import java.util.Iterator; import java.util.Scanner; /** * @fileName : day06_Demo3.java * @description : TODO * @author : yangzhihong * @date : 2021年12月18日-下午3:41:42 */ public class day06_Demo3 { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月18日下午3:41:42 */ public static void main(String[] args) { int a, n; //从控制台输入 Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个数：\"); a = sc.nextInt(); System.out.println(\"请输入需要相加的个数：\"); n = sc.nextInt(); long b = a; //每个加数 long num = 0; //和 int count = 1; //循环相加 for(int i = 0;i &lt; n;i++) { System.out.println(\"第\" + count + \"次增加：\" + b); num += b; //计数器 count++; //改变加数 b *= 10; b += a; } System.out.println(\"\\n\" + n + \"次相加的结果为= \" + num); } } ​ 4.将所有的五位数中的回文数打印输出。即12321是回文数，个位与万位相同，十位与干位相同。 package day06; /** * @fileName : day06_Demo5.java * @description : TODO * @author : yangzhihong * @date : 2021年12月18日-下午4:47:48 */ public class day06_Demo5 { public static void main(String[] args) { int x, y, z, h, n; for (int i = 10000; i &lt; 100000;i++) { x = i / 10000; y = i / 1000 % 10; z = i / 100 % 10; h = i / 10 % 10; n = i % 10; if (n == x &amp;&amp; h == y) { System.out.println(i); } } } } ​ 5.公园里有一只猴子和一堆桃子，猴子每天吃掉桃子总数的一半，把剩下一半中扔掉一个坏的。到第七天的时候，猴子睁开眼发现只剩下一个桃子。问公园里刚开始有多少个桃子？ package day06; /** * @fileName : day06_Demo6.java * @description : 公园里有一只猴子和一堆桃子，猴子每天吃掉桃子总数的一半， * 把剩下一半中扔掉一个坏的。到第七天的时候，猴子睁开眼发现只剩下一个桃子。 * 问公园里刚开始有多少个桃子？ * @author : yangzhihong * @date : 2021年12月19日-下午3:49:21 */ public class day06_Demo6 { public static void main(String[] args) { int count = 1; for(int a=1;a&lt;=6;a++) { count = (count+1) * 2; } System.out.println(\"公园里原来有: \"+count+\"个桃子。\"); } } ​ 6.国王的奖励：有一个棋盘，有64个方格，在第一个方格里面放1粒芝麻重量是0.00001kg，第二个里面放2粒，第三个里面放4，求棋盘上放的所有芝麻的重量。 package day06; import java.util.Iterator; /** * @fileName : day06_Demo7.java * @description : TODO * @author : yangzhihong * @date : 2021年12月19日-下午2:11:12 */ public class day06_Demo7 { /** * @return : void * @Description : 有一个棋盘，有64个方格，在第一个方格里面放1粒芝麻重量是0.00001kg， * 第二个里面放2粒，第三个里面放4，求棋盘上放的所有芝麻的重量。 * @author : yangzhihong * @Date : 2021年12月19日下午2:11:12 */ public static void main(String[] args) { double sum = 0; for (int i = 0; i &lt; 64; i++) { sum += Math.pow(2,i); } System.out.println(\"sum =\" + sum / 10000); } } ​ 7.实现1!+2!+3!+4!+5!+….+n!，n为n的阶乘 等于 1 * 2 * 3 * 4…….* n? package day06; /** * @fileName : day06_Demo8.java * @description : TODO * @author : yangzhihong * @date : 2021年12月20日-上午9:40:51 */ public class day06_Demo8 { /** * @return : void * @Description : 实现1!+2!+3!+4!+5!+....+n! * n！为n的阶乘 等于 1 * 2 * 3 * 4.......* n？ * @author : yangzhihong * @Date : 2021年12月20日上午9:40:51 */ public static void main(String[] args) { int n = 5; int a = 1; int sum = 0; for (int i = 1; i &lt; n; i++) { a *= i; sum += a; } System.out.println(sum); } } ​ 8.【折纸问题】一张纸的厚度大约是0.08mm，对折多少次之后能达到珠穆朗玛峰的高度(8848.13米)？ package day06; /** * @fileName : day06_Demo9.java * @description : TODO * @author : yangzhihong * @date : 2021年12月20日-上午9:04:24 */ public class day06_Demo9 { /** * @return : void * @Description : 一张纸的厚度大约是0.08mm， * 对折多少次之后能达到珠穆朗玛峰的高度（8848.13米）？ * @author : yangzhihong * @Date : 2021年12月20日上午9:04:24 */ public static void main(String[] args) { int sum = 8; int count = 0; for (double i = 0;; i++) { sum = sum * 2; count++; if (sum >= 884813000) { System.out.println(\"次数为：\" + count); System.out.println(sum); break; } } } }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"}]},{"title":"面向对象（多态）","slug":"面向对象（多态）","date":"2021-09-12T10:00:11.000Z","updated":"2022-07-14T12:03:14.000Z","comments":true,"path":"2021/09/12/面向对象（多态）/","link":"","permalink":"https://aloctw.github.io/2021/09/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/","excerpt":"","text":"面向对象—多态&amp;emsp;&amp;emsp;一、多态：同一个对象具有多种形态&amp;emsp;&amp;emsp;二、作用：核心在于方法的重写、覆写，使多种数据类型进行统一，让程序具有超强的扩展性。&amp;emsp;&amp;emsp;三、模拟人物进行网络游戏：类图： 创建游戏父类： /** * @fileName : Game.java * @description : TODO * @author : yangzhihong * @date : 2021年12月15日-上午11:39:08 */ public class Game { public void start() { System.out.println(\"开机上号！\"); } public void play() { System.out.println(\"热血沸腾，沉迷其中无法自拔！\"); } public void end() { System.out.println(\"收工，回家吃饭！\\n\"); } } DNF游戏类： public class DNF extends Game { public void play() { System.out.println(\"刷刷刷，刷图使我快乐！\"); } } LOL游戏类： public class LOL extends Game { public void play() { System.out.println(\"沉迷在联盟的世界无法自拔\"); } public void gailun() { System.out.println(\"来一波盖伦大宝剑！\"); } } CS游戏类： public class CS extends Game { public void play() { System.out.println(\"没有八倍镜，照样干翻对面！\"); } } 人物类： public class Player { public void happy(Game game) { game.start(); game.play(); game.end(); } } 场景类，执行游戏入口： public static void main(String[] args) { Game game1 = new DNF(); //向上转型 Game game2 = new LOL(); Game game3 = new CS(); LOL g = (LOL)game2; //向下转型 g.gailun(); Player p = new Player(); p.happy(game1); p.happy(game2); p.happy(game3); } } 小小总结：1.向上转型：把子类的对象转化为父类的变量 &amp;emsp;缺点：会屏蔽掉子类中特有的方法 2.向下转型：把父类的变量转化回子类的变量 &amp;emsp;缺点：转化有风险，java要求必须写强制转化，格式（向上转化后的数据类型）变量 3.两个没有关系的类对象是不能够转型的，一定会产生ClassCastException","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://aloctw.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"多态","slug":"多态","permalink":"https://aloctw.github.io/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"面向对象：来一场植物大战僵尸","slug":"面向对象来一场植物大战僵尸","date":"2021-09-10T09:22:20.000Z","updated":"2022-07-14T12:02:52.000Z","comments":true,"path":"2021/09/10/面向对象来一场植物大战僵尸/","link":"","permalink":"https://aloctw.github.io/2021/09/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%B8%80%E5%9C%BA%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","excerpt":"","text":"一、面向对象：来一场植物大战僵尸&amp;emsp;&amp;emsp;1.我们先要准备植物类，僵尸类、场景类。&amp;emsp;&amp;emsp;2.植物类来存放植物的属性与动作方法，僵尸类存放僵尸的属性与动作方法，在场景类中创建具体的植物与僵尸，并调用它们的动作。&amp;emsp;&amp;emsp;3.植物类/** * @fileName : zhiwu.java * @description : TODO * @author : yangzhihong * @date : 2021年12月15日-上午9:43:05 */ public class zhiwu { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月15日上午9:43:05 */ String name; int hp; int attack; zhiwu (String name,int hp,int attack){ this.name=name; this.hp=hp; this.attack=attack; } public void fight(jiangshi js) { System.out.println(this.name+\"在攻击\"+js.name); js.hp -= this.attack; System.out.println(js.name+\"的血量剩余\"+js.hp+\"\\n\"); } } &amp;emsp;&amp;emsp;4.僵尸类：/** * @fileName : jiangshi.java * @description : TODO * @author : yangzhihong * @date : 2021年12月15日-上午9:50:59 */ public class jiangshi { String name; int hp; int attack; jiangshi(String name,int hp,int attack){ this.name = name; this.hp = hp; this.attack = attack; } public void eat(zhiwu zw) { System.out.println(this.name+\"在攻击\"+zw.name); zw.hp -= this.attack; System.out.println(zw.name+\"的血量还剩余\"+zw.hp); } } &amp;emsp;&amp;emsp;5.场景类：/** * @fileName : Client.java * @description : TODO * @author : yangzhihong * @date : 2021年12月15日-上午9:57:43 */ public class Client { /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月15日上午9:57:43 */ public static void main(String[] args) { zhiwu zw = new zhiwu(\"豌豆射手\",1000,50); jiangshi js = new jiangshi(\"僵尸博士\",800,60); System.out.println(\"植物:\"+zw.name+\"\\n血量:\"+zw.hp+\"\\n攻击力:\"+zw.attack+\"\\n\"); System.out.println(\"僵尸:\"+js.name+\"\\n血量:\"+js.hp+\"\\n攻击力:\"+js.attack+\"\\n\"); zw.fight(js); js.eat(zw); } } &amp;emsp;&amp;emsp;6.来个小小的总结：①图纸类中描述对象的属性与动作，构造方法来实现，创建对象实例化使他们“动起来”。 ②不一定所有代码都写在一个类里。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"https://aloctw.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"交换变量值的四种方法","slug":"交换变量值的四种方法","date":"2021-08-25T09:17:38.000Z","updated":"2022-07-14T12:02:24.000Z","comments":true,"path":"2021/08/25/交换变量值的四种方法/","link":"","permalink":"https://aloctw.github.io/2021/08/25/%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、将两个变量的值互相交换方法一：使用中间变量交换，非常靠谱，适用于数值、字符串等。 方法二：^异或，但只使用于数值。 方法三：+- ，适用于数值。 方法四：*&#x2F; ，适用于数值，但不适用于其中一个变量为0 的情况。 程序运行结果： 程序代码：/** * @fileName : exchange2Var.java * @description : TODO * @author : yangzhihong * @date : 2021年12月14日-下午4:18:31 */ public class exchange2Var { public static void main(String[] args) { int a = 3, b = 5; //方法一：使用中间变量交换 extracted1(a, b); //方法二：^异或 只使用于数值 extracted2(a, b); //方法三：+- extracted3(a, b); //方法四：*/ 不适用于其中一个变量为0 的情况 extracted4(a, b); } /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月14日下午5:16:14 */ private static void extracted4(int a, int b) { System.out.println(\"方法四：\"); System.out.println(\"[交换前]\\ta=\"+a+\"\\tb=\"+b); a = a * b; b = a / b; a = a / b; System.out.println(\"[交换后]\\ta=\"+a+\"\\tb=\"+b); } /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月14日下午5:06:25 */ private static void extracted3(int a, int b) { System.out.println(\"方法三：\"); System.out.println(\"[交换前]\\ta=\"+a+\"\\tb=\"+b); a = a + b; b = a - b; a = a - b; System.out.println(\"[交换后]\\ta=\"+a+\"\\tb=\"+b+\"\\n\"); } /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月14日下午4:36:07 */ private static void extracted2(int a, int b) { System.out.println(\"方法二：\"); System.out.println(\"[交换前]\\ta=\"+a+\"\\tb=\"+b); a ^= b; b ^= a; a ^= b; System.out.println(\"[交换后]\\ta=\"+a+\"\\tb=\"+b+\"\\n\"); } /** * @return : void * @Description : TODO * @author : yangzhihong * @Date : 2021年12月14日下午4:33:15 */ private static void extracted1(int a, int b) { System.out.println(\"方法一：\"); System.out.println(\"[交换前]\\ta=\"+a+\"\\tb=\"+b); int c = a; a = b; b = c; System.out.println(\"[交换后]\\ta=\"+a+\"\\tb=\"+b+\"\\n\"); } }","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"变量","slug":"变量","permalink":"https://aloctw.github.io/tags/%E5%8F%98%E9%87%8F/"}]},{"title":"Switch_case语句、年月日计算","slug":"Switch case语句、年月日计算","date":"2021-08-22T08:48:35.000Z","updated":"2022-07-14T12:01:42.000Z","comments":true,"path":"2021/08/22/Switch case语句、年月日计算/","link":"","permalink":"https://aloctw.github.io/2021/08/22/Switch%20case%E8%AF%AD%E5%8F%A5%E3%80%81%E5%B9%B4%E6%9C%88%E6%97%A5%E8%AE%A1%E7%AE%97/","excerpt":"","text":"一、switch后面允许有哪些类型？byte、short、char、int、enum、StringJDK1.5后允许有enum枚举类型。JDK1.8后允许有String类型。 二、Switch case语句格式：switch(变量){ case 值(常量表达式)1: //...; break; case 值(常量表达式)2: //...; break; ... case default: //默认处理 break; } 三、switch case执行时，一定会先进行匹配，匹配成功返回当前case的值，再根据是否有break，判断是否继续输出，或是跳出判断。四、程序结果 五、 代码如下：import java.util.Scanner; /** * @fileName : ClacDay.java * @description : TODO * @author : yangzhihong * @date : 2021年12月14日-下午3:37:07 */ public class ClacDay { public static void main(String[] args) { //1.获取控制台输入的年月日 Scanner scanner = new Scanner(System.in); System.out.println(\"请输入年份：\"); int year = scanner.nextInt(); System.out.println(\"请输入月份：\"); int month = scanner.nextInt(); System.out.println(\"请输入日期：\"); int day = scanner.nextInt(); //2.计算二月份的天数 //int daysofFeb = calcfebDays(year); //3.使用Switch case累加天数 int sum = 0; switch (month) { case 12:sum += 30; case 11:sum += 31; case 10:sum += 30; case 9: sum += 31; case 8: sum += 31; case 7: sum += 30; case 6: sum += 31; case 5: sum += 30; case 4: sum += 31; case 3: sum += calcfebDays(year); case 2: sum += 31; case 1: sum += day; default: break; } System.out.println(year+\"年\"+month+\"月\"+day+\"日\"); System.out.println(\"是\"+year+\"年的第\"+sum+\"天！\"); } //能够被4整除并不能被100整除，或能够被400整除来计算是否为闰年 public static int calcfebDays(int year) { //判断二月份是否为闰年，使用三目运算符 return year % 4 ==0 &amp;&amp; year % 100 !=0 || year % 400 ==0 ? 29 : 28; } public static int calcfebDays2(int year) { //使用if判断语句 if(year % 4 ==0 &amp;&amp; year % 100 !=0 || year % 400 ==0) { return 29; } return 28; } } 六、 还需注意的是当进行case判断时，JVM会自动从上到下扫描，寻找匹配的case，case后面只能是常量，可以是运算表达式，但一定要符合正确的类型。不能是变量，即便变量在之前进行了赋值，JVM依然会报错。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"}]},{"title":"数据类型、数据转换、变量","slug":"java基础（数据类型、数据转换、变量）","date":"2021-08-21T01:42:47.000Z","updated":"2022-07-14T12:01:06.000Z","comments":true,"path":"2021/08/21/java基础（数据类型、数据转换、变量）/","link":"","permalink":"https://aloctw.github.io/2021/08/21/java%E5%9F%BA%E7%A1%80%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E3%80%81%E5%8F%98%E9%87%8F%EF%BC%89/","excerpt":"","text":"一、java中数据类型有哪些？&amp;emsp;&amp;emsp;java语言的数据类型分为两种：基本数据类型和引用数据类型。&amp;emsp;&amp;emsp;①.基本数据类型： 名称 关键字 占用空间 取值范围 字节型 byte 1字节 【-128~127】 短整型 short 2字节 【-32768~32767】 整型 int 4字节 【-2^31~2^31 -1】 长整型 long 8字节 【-2^63~2^63 -1】 单精度浮点型 float 4字节 【+&#x2F;-3.4E+38F】 双精度浮点型 double 8字节 【+&#x2F;-1.8E+308】 字符型 char 2字节 【0 ~ 65535】 布尔型 boolean 1字节 【true&#x2F;false】 &amp;emsp;&amp;emsp;②.引用数据类型： 三种：数组[]、接口interface、类Class 所有除八大基本数据类型外的都是引用数据类型，并且默认值为null。 引用数据类型是由用户自定义，用来限制其他数据类型。 二、java中数据类型的转换？&amp;emsp;&amp;emsp;①.低级到高级： (byte、short、char)–&gt;int–&gt;long–&gt;float–&gt;double 低优先级 + 高优先级 –&gt;高优先级。 低级转换高级：自动类型转换； 高级转低级 ：强制类型转换； &amp;emsp;&amp;emsp;②.强制转换的过程中可能造成数据丢失。&amp;emsp;&amp;emsp;③.强制类型转换时要在需要转换的数据类型前加上()。三、成员变量和局部变量的区别？&amp;emsp;&amp;emsp;①.位置不同 成员变量：直接写在类中，方法外部。 局部变量：在方法内部。 &amp;emsp;&amp;emsp;②.作用的范围不同 成员变量：在类里面可以通用。 局部变量：只能在方法里面用。 &amp;emsp;&amp;emsp;③.默认值不同 成员变量：若无赋值，则为默认值。 局部变量：必须赋值使用。 &amp;emsp;&amp;emsp;④.内存中位置不同 成员变量：堆内存。 局部变量：栈内存。 &amp;emsp;&amp;emsp;⑤.生命周期不同 成员变量：对象的创建而存在，对象的消亡而消失。 局部变量：方法或代码块的使用而存在，完成而消失。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"}]}],"categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://aloctw.github.io/tags/Spring/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://aloctw.github.io/tags/RabbitMQ/"},{"name":"Redis","slug":"Redis","permalink":"https://aloctw.github.io/tags/Redis/"},{"name":"spring","slug":"spring","permalink":"https://aloctw.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://aloctw.github.io/tags/springboot/"},{"name":"框架","slug":"框架","permalink":"https://aloctw.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"注解","slug":"注解","permalink":"https://aloctw.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"数据库","slug":"数据库","permalink":"https://aloctw.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://aloctw.github.io/tags/MyBatis/"},{"name":"缓存","slug":"缓存","permalink":"https://aloctw.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://aloctw.github.io/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"},{"name":"MySQL","slug":"MySQL","permalink":"https://aloctw.github.io/tags/MySQL/"},{"name":"Go","slug":"Go","permalink":"https://aloctw.github.io/tags/Go/"},{"name":"Golang","slug":"Golang","permalink":"https://aloctw.github.io/tags/Golang/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://aloctw.github.io/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://aloctw.github.io/tags/DOM/"},{"name":"HTML","slug":"HTML","permalink":"https://aloctw.github.io/tags/HTML/"},{"name":"Java","slug":"Java","permalink":"https://aloctw.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://aloctw.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"线程安全","slug":"线程安全","permalink":"https://aloctw.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"IO流","slug":"IO流","permalink":"https://aloctw.github.io/tags/IO%E6%B5%81/"},{"name":"字节缓冲流","slug":"字节缓冲流","permalink":"https://aloctw.github.io/tags/%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81/"},{"name":"函数方法","slug":"函数方法","permalink":"https://aloctw.github.io/tags/%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"https://aloctw.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"面向对象","slug":"面向对象","permalink":"https://aloctw.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"多态","slug":"多态","permalink":"https://aloctw.github.io/tags/%E5%A4%9A%E6%80%81/"},{"name":"变量","slug":"变量","permalink":"https://aloctw.github.io/tags/%E5%8F%98%E9%87%8F/"}]}