{"meta":{"title":"Aloctw","subtitle":"の陈十二吖","description":"十二加油站！","author":"Aloctw","url":"https://aloctw.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-07-02T06:54:16.000Z","updated":"2022-07-02T06:57:21.324Z","comments":false,"path":"categories/index.html","permalink":"https://aloctw.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-02T06:55:04.000Z","updated":"2022-07-02T06:58:53.420Z","comments":false,"path":"about/index.html","permalink":"https://aloctw.github.io/about/index.html","excerpt":"","text":""},{"title":"友情连接","date":"2022-07-02T06:59:17.000Z","updated":"2022-07-02T06:59:48.863Z","comments":false,"path":"friends/index.html","permalink":"https://aloctw.github.io/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-02T06:54:40.000Z","updated":"2022-07-02T06:58:12.012Z","comments":false,"path":"tags/index.html","permalink":"https://aloctw.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jdbc","slug":"jdbc","date":"2022-03-21T12:26:24.000Z","updated":"2022-03-22T06:25:42.674Z","comments":true,"path":"2022/03/21/jdbc/","link":"","permalink":"https://aloctw.github.io/2022/03/21/jdbc/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"Aloctw"},{"title":"","slug":"线程与进程","date":"2022-03-14T03:39:44.625Z","updated":"2022-03-01T08:06:26.790Z","comments":true,"path":"2022/03/14/线程与进程/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"1、线程与线程1.1 进程 进程：正在运行的程序 是系统进行分配的调用和独立单位 每一个进程都有自己的内存空间和系统资源 1.2 线程 线程：是进程中的单个控制流程，是一条执行路径 单线程：一个进程如果只有一条执行路径，则称之为单线程 多线程：一个进行如果有多个执行路径，则成为多线程 2、多线程的实现方式2.1 创建线程对象定义一个类来继承Thread类，并且在定义类中重写Thread的run()；方法，然后在创建定义类对象，最后启动线程 例： package com.dyh.thread; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /* 定义一个类来继承Thread类， 并且在定义类中重写Thread的run();方法， 然后在创建定义类对象，最后启动线程 */ class ThreadDome extends Thread &#123; @Override public void run() &#123; for (int i = 52; i &lt;63 ; i++) &#123; //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(&quot;今日的车次有以下：&quot; + getName() + &quot;: G&quot; + i); &#125; &#125; &#125; public class ThreadDome01 &#123; public static void main(String[] args) &#123; //创建线程对象（开辟线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(&quot;复兴号&quot;); td1.setName(&quot;和谐号&quot;); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); //创建main主线程（主线程优先级高于子线程） //Thread.currentThread().getName()，打印线程名称 for (int i = 0; i &lt; 100 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125; &#125; 2.2 Runnable接口自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中run()方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 需要在new一个线程（Thread）对象出来，进行调用这个任务类（Thread(Runnable target, String name)） 例： package com.dyh.thread; /* 自定义一个类实现Runnable接口，这个类是一个任务类， 这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象， 如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 */ //首先自定义一个任务类 class Myrunnble implements Runnable &#123; //重写Thread的Run()方法 //Thread.currentThread().getName()打印出线程的名称 @Override public void run() &#123; for (int i = 0; i &lt; 100 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;--&quot; + i); &#125; &#125; &#125; public class ThreadRunnable &#123; public static void main(String[] args) &#123; //创建任务对象 Myrunnble mr = new Myrunnble(); //创建一个线程 //Thread(Runnable target, String name) //指的就是Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target //分配一个新的 Thread对象。 Thread thread = new Thread(mr, &quot;高铁&quot;); thread.start(); //创建主线程（主线程优先级高于子线程） for (int j = 0; j &lt; 100; j++) &#123; System.out.println(Thread.currentThread().getName() + &quot; -&quot; + j); &#125; &#125; &#125; 2.3Callable接口package com.dyh.thread; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* 1、创建一个Callable接口实现类，实现call()方法，该call()方法作为执行体 且没有返回值 2、使用FutureTast类来包装Callable对象，该FutureTast对象封装了 该Callable对象的call()方法的返回值 3、使用FutureTast对象作为Thread对象的target创建并启动线程。 //Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target 4、调用FutureTast对象的get()方法来获取子线程执行结束后的返回值 */ // 实现了Callable接口的类，也是一个任务类 class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; //书写方法体 for (int i = 0; i &lt;= 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; //返回-1则表明线程结束 return -1; &#125; &#125; public class ThreadCallable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //创建任务对象 MyCallable mc = new MyCallable(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 //使用FutureTast来包装Callable对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(mc); //创建一个线程对象 //因为FutureTask对象这个对象实现了RunnableFuture接口 Thread thread = new Thread(task, &quot;高铁&quot;); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;-&quot; + i); &#125; //通过get()方法来获取Callable任务方法的返回值、 //isDone判断该Callable任务是否完成 if (task.isDone()) &#123; Integer integer = task.get(); System.out.println(integer); &#125; &#125; &#125; 3、小结3.1为什么要重写run();方法？ run();方法是用来封装被线程执行的代码 class ThreadDome extends Thread &#123; @Override public void run() &#123; //格式化时间（设置控制台输出的时间格式） SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); //获取当前时间，sdf.format(d)格式化时间 Date d = new Date(); for (int i = 52; i &lt;63 ; i++) &#123; //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(&quot;今日日期为：&quot; + sdf.format(d) + &quot; 今日的车次有以下：&quot; + getName() + &quot;: G&quot; + i); &#125; &#125; &#125; 3.2 run();方法和start();方法的区别？ run()：方法是线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程，然后由JVM虚拟机来调用此线程的run()方法 3.3 设置和获取线程名称 void setName（String name）,将此线程的名称改为等于参数name（setName给线程赋值） //String getName()：返回此线程名称 public class ThreadDome01 &#123; public static void main(String[] args) &#123; //实例化ThreadDome（开辟两个线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(&quot;复兴号&quot;); td1.setName(&quot;和谐号&quot;); （String getName()：返回此线程名称）调用Thread类中的有参构造，直接在实例化的时候就进行赋值 //调用Thread的有参构造方法 class ThreadDome extends Thread &#123; private String name; //无参构造 public ThreadDome() &#123; &#125; //有参构造（调用父类的有参构造） public ThreadDome(String name) &#123; super(name); &#125; //run（）未重新 public class ThreadDome01 &#123; public static void main(String[] args) &#123; //String getName(); ThreadDome td = new ThreadDome(&quot;复兴号&quot;); ThreadDome td1 = new ThreadDome(&quot;和谐号&quot;); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); &#125; ​ 通过构造方法也可以设置线程名称 //Thread.currentThread().getName() for (int i = 0; i &lt; 100 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;--&quot; + i);&#125; 4、线程的生命周期（未完。。。）","categories":[],"tags":[]},{"title":"","slug":"多线程","date":"2022-03-14T03:39:44.610Z","updated":"2022-03-01T08:12:09.627Z","comments":true,"path":"2022/03/14/多线程/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1、线程与线程1.1 进程 进程：正在运行的程序 是系统进行分配的调用和独立单位 每一个进程都有自己的内存空间和系统资源 1.2 线程 线程：是进程中的单个控制流程，是一条执行路径 单线程：一个进程如果只有一条执行路径，则称之为单线程 多线程：一个进行如果有多个执行路径，则成为多线程 2、多线程的实现方式2.1 创建线程对象定义一个类来继承Thread类，并且在定义类中重写Thread的run()；方法，然后在创建定义类对象，最后启动线程 例： package com.dyh.thread; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /* 定义一个类来继承Thread类， 并且在定义类中重写Thread的run();方法， 然后在创建定义类对象，最后启动线程 */ class ThreadDome extends Thread &#123; @Override public void run() &#123; for (int i = 52; i &lt;63 ; i++) &#123; //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(&quot;今日的车次有以下：&quot; + getName() + &quot;: G&quot; + i); &#125; &#125; &#125; public class ThreadDome01 &#123; public static void main(String[] args) &#123; //创建线程对象（开辟线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(&quot;复兴号&quot;); td1.setName(&quot;和谐号&quot;); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); //创建main主线程（主线程优先级高于子线程） //Thread.currentThread().getName()，打印线程名称 for (int i = 0; i &lt; 100 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125; &#125; 2.2 Runnable接口自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中run()方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 需要在new一个线程（Thread）对象出来，进行调用这个任务类（Thread(Runnable target, String name)） 例： package com.dyh.thread; /* 自定义一个类实现Runnable接口，这个类是一个任务类， 这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象， 如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 */ //首先自定义一个任务类 class Myrunnble implements Runnable &#123; //重写Thread的Run()方法 //Thread.currentThread().getName()打印出线程的名称 @Override public void run() &#123; for (int i = 0; i &lt; 100 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;--&quot; + i); &#125; &#125; &#125; public class ThreadRunnable &#123; public static void main(String[] args) &#123; //创建任务对象 Myrunnble mr = new Myrunnble(); //创建一个线程 //Thread(Runnable target, String name) //指的就是Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target //分配一个新的 Thread对象。 Thread thread = new Thread(mr, &quot;高铁&quot;); thread.start(); //创建主线程（主线程优先级高于子线程） for (int j = 0; j &lt; 100; j++) &#123; System.out.println(Thread.currentThread().getName() + &quot; -&quot; + j); &#125; &#125; &#125; 2.3Callable接口package com.dyh.thread; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* 1、创建一个Callable接口实现类，实现call()方法，该call()方法作为执行体 且没有返回值 2、使用FutureTast类来包装Callable对象，该FutureTast对象封装了 该Callable对象的call()方法的返回值 3、使用FutureTast对象作为Thread对象的target创建并启动线程。 //Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target 4、调用FutureTast对象的get()方法来获取子线程执行结束后的返回值 */ // 实现了Callable接口的类，也是一个任务类 class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; //书写方法体 for (int i = 0; i &lt;= 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; //返回-1则表明线程结束 return -1; &#125; &#125; public class ThreadCallable &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //创建任务对象 MyCallable mc = new MyCallable(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 //使用FutureTast来包装Callable对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(mc); //创建一个线程对象 //因为FutureTask对象这个对象实现了RunnableFuture接口 Thread thread = new Thread(task, &quot;高铁&quot;); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;-&quot; + i); &#125; //通过get()方法来获取Callable任务方法的返回值、 //isDone判断该Callable任务是否完成 if (task.isDone()) &#123; Integer integer = task.get(); System.out.println(integer); &#125; &#125; &#125; 3、小结3.1为什么要重写run();方法？ run();方法是用来封装被线程执行的代码 class ThreadDome extends Thread &#123; @Override public void run() &#123; //格式化时间（设置控制台输出的时间格式） SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); //获取当前时间，sdf.format(d)格式化时间 Date d = new Date(); for (int i = 52; i &lt;63 ; i++) &#123; //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(&quot;今日日期为：&quot; + sdf.format(d) + &quot; 今日的车次有以下：&quot; + getName() + &quot;: G&quot; + i); &#125; &#125; &#125; 3.2 run();方法和start();方法的区别？ run()：方法是线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程，然后由JVM虚拟机来调用此线程的run()方法 3.3 设置和获取线程名称 void setName（String name）,将此线程的名称改为等于参数name（setName给线程赋值） //String getName()：返回此线程名称 public class ThreadDome01 &#123; public static void main(String[] args) &#123; //实例化ThreadDome（开辟两个线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(&quot;复兴号&quot;); td1.setName(&quot;和谐号&quot;); （String getName()：返回此线程名称）调用Thread类中的有参构造，直接在实例化的时候就进行赋值 //调用Thread的有参构造方法 class ThreadDome extends Thread &#123; private String name; //无参构造 public ThreadDome() &#123; &#125; //有参构造（调用父类的有参构造） public ThreadDome(String name) &#123; super(name); &#125; //run（）方法未重写 public class ThreadDome01 &#123; public static void main(String[] args) &#123; //String getName(); ThreadDome td = new ThreadDome(&quot;复兴号&quot;); ThreadDome td1 = new ThreadDome(&quot;和谐号&quot;); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); &#125; ​ 通过构造方法也可以设置线程名称 //Thread.currentThread().getName() for (int i = 0; i &lt; 100 ; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;--&quot; + i);&#125; 4、线程的生命周期（未完。。。）","categories":[],"tags":[]},{"title":"","slug":"多线程生命周期","date":"2022-03-14T03:39:44.610Z","updated":"2022-03-02T01:37:39.041Z","comments":true,"path":"2022/03/14/多线程生命周期/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"1.生命周期1.1 多线程生命周期的六种状态（官方文档） 线程的状态我们可以在api文档中搜索Thread.State便可以得到下列的六种状态。 线程状态 描述 官方解释（api） 新建状态（NEW） 创建线程对象 线程尚未开始在这个国家 可运行状态（RUNNABLE） start()方法 正在java虚拟机中执行的线程 阻塞状态（BLOCKED） 无法获得锁对象 受阻塞并等待某个监视器锁的线程 无限等待状态（WAITING） wait()，join()方法 处于这种状态的线程被无限期地等待另一个线程来执行特定的动作。 超时等待状态（TIMEND_WAITING） sleep()方法 无限期的等待另一个线程来执行某一特定操作的线程 终止状态（TERMINATED） 全部代码运行完毕 已退出的线程处于这种状态 （附图）网上copy来的 Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态，线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换 这些状态是不反映任何操作系统线程状态的虚拟机状态 1.2 生命周期六种状态源码public enum State &#123; /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; &#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-12T05:06:58.375Z","updated":"2022-03-12T05:06:58.375Z","comments":true,"path":"2022/03/12/hello-world/","link":"","permalink":"https://aloctw.github.io/2022/03/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://aloctw.github.io/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125; # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125; # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125; # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125; # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： &#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： &#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://aloctw.github.io/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://aloctw.github.io/tags/%E6%82%A6%E8%AF%BB/"}],"author":"hojun"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://aloctw.github.io/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://aloctw.github.io/tags/%E6%82%A6%E8%AF%BB/"}]}