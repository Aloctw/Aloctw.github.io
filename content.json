{"meta":{"title":"Aloctw","subtitle":"の陈十二吖","description":"十二加油站！","author":"Aloctw","url":"https://aloctw.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-07-02T06:55:04.000Z","updated":"2022-07-02T06:58:53.420Z","comments":false,"path":"about/index.html","permalink":"https://aloctw.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-02T06:54:16.000Z","updated":"2022-07-02T06:57:21.324Z","comments":false,"path":"categories/index.html","permalink":"https://aloctw.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情连接","date":"2022-07-02T06:59:17.000Z","updated":"2022-07-02T06:59:48.863Z","comments":false,"path":"friends/index.html","permalink":"https://aloctw.github.io/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-02T06:54:40.000Z","updated":"2022-07-02T06:58:12.012Z","comments":false,"path":"tags/index.html","permalink":"https://aloctw.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jdbc","slug":"jdbc","date":"2022-03-21T12:26:24.000Z","updated":"2022-03-22T06:25:42.674Z","comments":true,"path":"2022/03/21/jdbc/","link":"","permalink":"https://aloctw.github.io/2022/03/21/jdbc/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"Aloctw"},{"title":"","slug":"线程与进程","date":"2022-03-14T03:39:44.625Z","updated":"2022-03-01T08:06:26.790Z","comments":true,"path":"2022/03/14/线程与进程/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"1、线程与线程1.1 进程 进程：正在运行的程序 是系统进行分配的调用和独立单位 每一个进程都有自己的内存空间和系统资源 1.2 线程 线程：是进程中的单个控制流程，是一条执行路径 单线程：一个进程如果只有一条执行路径，则称之为单线程 多线程：一个进行如果有多个执行路径，则成为多线程 2、多线程的实现方式2.1 创建线程对象定义一个类来继承Thread类，并且在定义类中重写Thread的run()；方法，然后在创建定义类对象，最后启动线程 例： package com.dyh.thread; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /* 定义一个类来继承Thread类， 并且在定义类中重写Thread的run();方法， 然后在创建定义类对象，最后启动线程 */ class ThreadDome extends Thread { @Override public void run() { for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日的车次有以下：\" + getName() + \": G\" + i); } } } public class ThreadDome01 { public static void main(String[] args) { //创建线程对象（开辟线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); //创建main主线程（主线程优先级高于子线程） //Thread.currentThread().getName()，打印线程名称 for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } } } 2.2 Runnable接口自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中run()方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 需要在new一个线程（Thread）对象出来，进行调用这个任务类（Thread(Runnable target, String name)） 例： package com.dyh.thread; /* 自定义一个类实现Runnable接口，这个类是一个任务类， 这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象， 如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 */ //首先自定义一个任务类 class Myrunnble implements Runnable { //重写Thread的Run()方法 //Thread.currentThread().getName()打印出线程的名称 @Override public void run() { for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i); } } } public class ThreadRunnable { public static void main(String[] args) { //创建任务对象 Myrunnble mr = new Myrunnble(); //创建一个线程 //Thread(Runnable target, String name) //指的就是Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target //分配一个新的 Thread对象。 Thread thread = new Thread(mr, \"高铁\"); thread.start(); //创建主线程（主线程优先级高于子线程） for (int j = 0; j &lt; 100; j++) { System.out.println(Thread.currentThread().getName() + \" -\" + j); } } } 2.3Callable接口package com.dyh.thread; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* 1、创建一个Callable接口实现类，实现call()方法，该call()方法作为执行体 且没有返回值 2、使用FutureTast类来包装Callable对象，该FutureTast对象封装了 该Callable对象的call()方法的返回值 3、使用FutureTast对象作为Thread对象的target创建并启动线程。 //Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target 4、调用FutureTast对象的get()方法来获取子线程执行结束后的返回值 */ // 实现了Callable接口的类，也是一个任务类 class MyCallable implements Callable&lt;Integer> { @Override public Integer call() throws Exception { //书写方法体 for (int i = 0; i &lt;= 100; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } //返回-1则表明线程结束 return -1; } } public class ThreadCallable { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建任务对象 MyCallable mc = new MyCallable(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 //使用FutureTast来包装Callable对象 FutureTask&lt;Integer> task = new FutureTask&lt;>(mc); //创建一个线程对象 //因为FutureTask对象这个对象实现了RunnableFuture接口 Thread thread = new Thread(task, \"高铁\"); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + \"-\" + i); } //通过get()方法来获取Callable任务方法的返回值、 //isDone判断该Callable任务是否完成 if (task.isDone()) { Integer integer = task.get(); System.out.println(integer); } } } 3、小结3.1为什么要重写run();方法？ run();方法是用来封装被线程执行的代码 class ThreadDome extends Thread { @Override public void run() { //格式化时间（设置控制台输出的时间格式） SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); //获取当前时间，sdf.format(d)格式化时间 Date d = new Date(); for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日日期为：\" + sdf.format(d) + \" 今日的车次有以下：\" + getName() + \": G\" + i); } } } 3.2 run();方法和start();方法的区别？ run()：方法是线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程，然后由JVM虚拟机来调用此线程的run()方法 3.3 设置和获取线程名称 void setName（String name）,将此线程的名称改为等于参数name（setName给线程赋值） //String getName()：返回此线程名称 public class ThreadDome01 { public static void main(String[] args) { //实例化ThreadDome（开辟两个线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); （String getName()：返回此线程名称）调用Thread类中的有参构造，直接在实例化的时候就进行赋值 //调用Thread的有参构造方法 class ThreadDome extends Thread { private String name; //无参构造 public ThreadDome() { } //有参构造（调用父类的有参构造） public ThreadDome(String name) { super(name); } //run（）未重新 public class ThreadDome01 { public static void main(String[] args) { //String getName(); ThreadDome td = new ThreadDome(\"复兴号\"); ThreadDome td1 = new ThreadDome(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); } ​ 通过构造方法也可以设置线程名称 //Thread.currentThread().getName() for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i);} 4、线程的生命周期（未完。。。）","categories":[],"tags":[]},{"title":"","slug":"多线程","date":"2022-03-14T03:39:44.610Z","updated":"2022-03-01T08:12:09.627Z","comments":true,"path":"2022/03/14/多线程/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1、线程与线程1.1 进程 进程：正在运行的程序 是系统进行分配的调用和独立单位 每一个进程都有自己的内存空间和系统资源 1.2 线程 线程：是进程中的单个控制流程，是一条执行路径 单线程：一个进程如果只有一条执行路径，则称之为单线程 多线程：一个进行如果有多个执行路径，则成为多线程 2、多线程的实现方式2.1 创建线程对象定义一个类来继承Thread类，并且在定义类中重写Thread的run()；方法，然后在创建定义类对象，最后启动线程 例： package com.dyh.thread; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /* 定义一个类来继承Thread类， 并且在定义类中重写Thread的run();方法， 然后在创建定义类对象，最后启动线程 */ class ThreadDome extends Thread { @Override public void run() { for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日的车次有以下：\" + getName() + \": G\" + i); } } } public class ThreadDome01 { public static void main(String[] args) { //创建线程对象（开辟线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); //创建main主线程（主线程优先级高于子线程） //Thread.currentThread().getName()，打印线程名称 for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } } } 2.2 Runnable接口自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中run()方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 需要在new一个线程（Thread）对象出来，进行调用这个任务类（Thread(Runnable target, String name)） 例： package com.dyh.thread; /* 自定义一个类实现Runnable接口，这个类是一个任务类， 这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象， 如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 */ //首先自定义一个任务类 class Myrunnble implements Runnable { //重写Thread的Run()方法 //Thread.currentThread().getName()打印出线程的名称 @Override public void run() { for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i); } } } public class ThreadRunnable { public static void main(String[] args) { //创建任务对象 Myrunnble mr = new Myrunnble(); //创建一个线程 //Thread(Runnable target, String name) //指的就是Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target //分配一个新的 Thread对象。 Thread thread = new Thread(mr, \"高铁\"); thread.start(); //创建主线程（主线程优先级高于子线程） for (int j = 0; j &lt; 100; j++) { System.out.println(Thread.currentThread().getName() + \" -\" + j); } } } 2.3Callable接口package com.dyh.thread; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* 1、创建一个Callable接口实现类，实现call()方法，该call()方法作为执行体 且没有返回值 2、使用FutureTast类来包装Callable对象，该FutureTast对象封装了 该Callable对象的call()方法的返回值 3、使用FutureTast对象作为Thread对象的target创建并启动线程。 //Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target 4、调用FutureTast对象的get()方法来获取子线程执行结束后的返回值 */ // 实现了Callable接口的类，也是一个任务类 class MyCallable implements Callable&lt;Integer> { @Override public Integer call() throws Exception { //书写方法体 for (int i = 0; i &lt;= 100; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } //返回-1则表明线程结束 return -1; } } public class ThreadCallable { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建任务对象 MyCallable mc = new MyCallable(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 //使用FutureTast来包装Callable对象 FutureTask&lt;Integer> task = new FutureTask&lt;>(mc); //创建一个线程对象 //因为FutureTask对象这个对象实现了RunnableFuture接口 Thread thread = new Thread(task, \"高铁\"); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + \"-\" + i); } //通过get()方法来获取Callable任务方法的返回值、 //isDone判断该Callable任务是否完成 if (task.isDone()) { Integer integer = task.get(); System.out.println(integer); } } } 3、小结3.1为什么要重写run();方法？ run();方法是用来封装被线程执行的代码 class ThreadDome extends Thread { @Override public void run() { //格式化时间（设置控制台输出的时间格式） SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); //获取当前时间，sdf.format(d)格式化时间 Date d = new Date(); for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日日期为：\" + sdf.format(d) + \" 今日的车次有以下：\" + getName() + \": G\" + i); } } } 3.2 run();方法和start();方法的区别？ run()：方法是线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程，然后由JVM虚拟机来调用此线程的run()方法 3.3 设置和获取线程名称 void setName（String name）,将此线程的名称改为等于参数name（setName给线程赋值） //String getName()：返回此线程名称 public class ThreadDome01 { public static void main(String[] args) { //实例化ThreadDome（开辟两个线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); （String getName()：返回此线程名称）调用Thread类中的有参构造，直接在实例化的时候就进行赋值 //调用Thread的有参构造方法 class ThreadDome extends Thread { private String name; //无参构造 public ThreadDome() { } //有参构造（调用父类的有参构造） public ThreadDome(String name) { super(name); } //run（）方法未重写 public class ThreadDome01 { public static void main(String[] args) { //String getName(); ThreadDome td = new ThreadDome(\"复兴号\"); ThreadDome td1 = new ThreadDome(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); } ​ 通过构造方法也可以设置线程名称 //Thread.currentThread().getName() for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i);} 4、线程的生命周期（未完。。。）","categories":[],"tags":[]},{"title":"","slug":"多线程生命周期","date":"2022-03-14T03:39:44.610Z","updated":"2022-03-02T01:37:39.041Z","comments":true,"path":"2022/03/14/多线程生命周期/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"1.生命周期1.1 多线程生命周期的六种状态（官方文档） 线程的状态我们可以在api文档中搜索Thread.State便可以得到下列的六种状态。 线程状态 描述 官方解释（api） 新建状态（NEW） 创建线程对象 线程尚未开始在这个国家 可运行状态（RUNNABLE） start()方法 正在java虚拟机中执行的线程 阻塞状态（BLOCKED） 无法获得锁对象 受阻塞并等待某个监视器锁的线程 无限等待状态（WAITING） wait()，join()方法 处于这种状态的线程被无限期地等待另一个线程来执行特定的动作。 超时等待状态（TIMEND_WAITING） sleep()方法 无限期的等待另一个线程来执行某一特定操作的线程 终止状态（TERMINATED） 全部代码运行完毕 已退出的线程处于这种状态 （附图）网上copy来的 Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态，线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换 这些状态是不反映任何操作系统线程状态的虚拟机状态 1.2 生命周期六种状态源码public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul> * &lt;li>{@link Object#wait() Object.wait} with no timeout&lt;/li> * &lt;li>{@link #join() Thread.join} with no timeout&lt;/li> * &lt;li>{@link LockSupport#park() LockSupport.park}&lt;/li> * &lt;/ul> * * &lt;p>A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt>Object.wait()&lt;/tt> * on an object is waiting for another thread to call * &lt;tt>Object.notify()&lt;/tt> or &lt;tt>Object.notifyAll()&lt;/tt> on * that object. A thread that has called &lt;tt>Thread.join()&lt;/tt> * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul> * &lt;li>{@link #sleep Thread.sleep}&lt;/li> * &lt;li>{@link Object#wait(long) Object.wait} with timeout&lt;/li> * &lt;li>{@link #join(long) Thread.join} with timeout&lt;/li> * &lt;li>{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li> * &lt;li>{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li> * &lt;/ul> */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; }","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-12T05:06:58.375Z","updated":"2022-03-12T05:06:58.375Z","comments":true,"path":"2022/03/12/hello-world/","link":"","permalink":"https://aloctw.github.io/2022/03/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]}