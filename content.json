{"meta":{"title":"Aloctw","subtitle":"の陈十二吖","description":"十二加油站！","author":"Aloctw","url":"https://aloctw.github.io","root":"/"},"pages":[{"title":"分类","date":"2022-07-02T06:54:16.000Z","updated":"2022-07-02T06:57:21.324Z","comments":false,"path":"categories/index.html","permalink":"https://aloctw.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-02T06:55:04.000Z","updated":"2022-07-02T06:58:53.420Z","comments":false,"path":"about/index.html","permalink":"https://aloctw.github.io/about/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-03T09:06:16.000Z","updated":"2022-07-03T09:06:47.116Z","comments":false,"path":"contact/index.html","permalink":"https://aloctw.github.io/contact/index.html","excerpt":"","text":""},{"title":"友情连接","date":"2022-07-02T06:59:17.000Z","updated":"2022-07-02T06:59:48.863Z","comments":false,"path":"friends/index.html","permalink":"https://aloctw.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-02T08:43:25.000Z","updated":"2022-07-02T08:44:06.351Z","comments":false,"path":"guestbook/index.html","permalink":"https://aloctw.github.io/guestbook/index.html","excerpt":"","text":"# 欢迎来到我的博客！ > 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度，在nickname栏目输入QQ号可以直接获取你的QQ头像。"},{"title":"标签","date":"2022-07-02T06:54:40.000Z","updated":"2022-07-02T06:58:12.012Z","comments":false,"path":"tags/index.html","permalink":"https://aloctw.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis穿透、击穿、雪崩","slug":"redis穿透、击穿、雪崩","date":"2022-07-09T11:31:21.000Z","updated":"2022-06-14T02:09:55.976Z","comments":true,"path":"2022/07/09/redis穿透、击穿、雪崩/","link":"","permalink":"https://aloctw.github.io/2022/07/09/redis%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/","excerpt":"","text":"Redis 缓存异常一、缓存雪崩 缓存雪崩是指缓存的 key 在同一时间大面积的失效，所以后面的请求都会落到数据库上面，造成数据库在短时间内承受大量请求而宕机。 解决方案： 缓存数据的过期时间设置随机，防止同一时间大量数据同时过期现象发生。 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 给每一个缓存数据增加响应的缓存标记，记录缓存是否失效，如果缓存标记失效则更新数据缓存。 二、缓存穿透 缓存穿透是指用户请求缓存和数据库中都没有的数据，导致请求落在数据库上，造成数据短时间内承受大量请求而宕机。 解决方案： 可以在缓存中增加一个 key-null 值，用户请求时直接返回一个 null 值。缓存的有效时间可以设置短一点，设置太长可能导致正常情况也无法使用。 可以采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。 三、缓存击穿 缓存击穿是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞，数据库瞬间压力过大宕机。 解决方案： 如果这个 key 被经常访问说明这是个热点 key ，可以设置这个热点 key 永不过期。 加互斥锁，使用 mutex 。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作，比如 Redis 的 SETNX 去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存； 也就是对缓存查询加锁，如果 KEY 不存在，就加锁，然后查数据库入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据。 四、缓存预热 缓存预热是指系统上限之后，将相关的缓存数据直接加载到缓存当中，这样可以避免在用户请求的时候直接查询数据库，这样用户直接请求到已被加载到缓存中数据。 解决方案： 直接写个缓存刷新页面，上线前手工操作。 相关的数据量不大的时候，可以在项目启动时自动加载。 定时刷新缓存。","categories":[{"name":"redis","slug":"redis","permalink":"https://aloctw.github.io/categories/redis/"}],"tags":[],"author":"shier"},{"title":"","slug":"ajax向后端发送请求","date":"2022-07-03T07:33:54.663Z","updated":"2022-06-10T02:06:53.176Z","comments":true,"path":"2022/07/03/ajax向后端发送请求/","link":"","permalink":"https://aloctw.github.io/2022/07/03/ajax%E5%90%91%E5%90%8E%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","excerpt":"","text":"几种简单发送AJAX请求的方式几种发送AJAX请求的方式概念Ajax &#x3D; 异步 Javascript + XML ， 是一种用于创建快速动态网页的技术。 优点可以实现不重新加载整个网页的情况下，对网页的某部分进行更新。 浏览器是单线程的，如果要实现多任务，为了防止任务卡主或者等待情况，就需要异步概念。 同步和异步的区别同步代码：代码是顺序执行的，根据代码定义顺序往下执行。异步代码：代码的执行顺序不是按定义执行，往往同步的代码先执行，再执行异步代码。XHR(XMLHttpRequest)对象XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用 发送ajax请求如果是get请求，参数直接拼接在url上发送。 post请求 参数放在请求体里面 post请求需要设置请求头，需要在open方法调用后再执行 xhr.setRequestHeader 例子 1、Get 请求通过 new 关键字 创建 xhr 实例 XMLHttpRequest const(局部) var(全局) const xhr = new XMLHttpRequest(); //2.xhr.open设置get请求的数据 xhr.open('请求方式','url') xhr.open('get','http://127.0.0.1:8080/validate?userName=tom') //3.1获取服务端响应的数据 xhr.onload = function(){ //3.2把json字符串转换为json对象 const res = JSON.parse(xhr.responseText); console.log(res) } //4.xhr.send发送数据 xhr.send(); 2、post 请求//1.创建实例 const xhr = new XMLHttpRequest(); //2.xhr.open 设置请求数据 xhr.open('post','http://127.0.0.1:8080/login') //3.设置请求头 xhr.setRequestHeader('content-type','application/x-www-form-urlencoded') //4.获取服务端响应的数据 xhr.onload = function(){ //4.1把json字符串转换为json对象 const res = JSON.parse(xhr.responseText); if(res.code === 200){ console.log(res.msg) } //5.post发送数据，在send里面发送参数 xhr.send('userName=tom'); 3、jQuery发送ajax请求$.ajax({type,url,data,success}) type: 请求的方式，默认是一个get请求 url: 请求的地址 data: 请求的参数 ，接收的是一个对象{ key: value } success: 成功回调，回调的第一个参数就是服务端返回的数据，他的格式是JSON对象 3.1jquery 的get请求//date请求参数可以拼接到url后面 $.ajax({ type:'get', //请求方式 url:'http://127.0.0.1:8080/my.do', //请求地址 data:{id:1}, //请求参数 success:function(res){ //如果获取数据成功，对数据进行处理 //res是服务器传递回来的数据，已经经过转换的JSON对象 if(res.code === 200){ console.log(res.data) } 3.2jquery 的post请求//post请求 $.ajax({ type:'post', //请求方式 url:'http://127.0.0.1:8080/my.do', //请求地址 data:{id:1}, //请求参数 success:function(res){ //如果获取数据成功，对数据进行处理 //res是服务器传递回来的数据，已经经过转换的JSON对象 if(res.code === 200){ console.log(res.data) } 4、$.get发送请求$.get(‘请求url’, ‘请求参数’, ‘请求回调函数’) function getJoke() { $.get('http://127.0.0.1:8080/my.do', { jokeId: 1 }, function(res) { $('#joke').html(res.data.content) }) } 5、$.post发送请求$.post(‘请求URL’, ‘请求参数’, ‘回调函数’) $.post('http://127.0.0.1:3001/my.do', { content: '转换的内容' }, function(res) { console.log(res) })","categories":[],"tags":[]},{"title":"","slug":"IO流","date":"2022-06-03T07:36:31.868Z","updated":"2022-04-15T08:26:02.921Z","comments":true,"path":"2022/06/03/IO流/","link":"","permalink":"https://aloctw.github.io/2022/06/03/IO%E6%B5%81/","excerpt":"","text":"Java_数据传输之自写字节缓冲流一、字节缓冲输出流 java.io.BufferedOutputStream extends OutputStream BufferedOutputStream：字节缓冲输出流。 继承自父类的共性成员方法： public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 构造方法： BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 参数： OutputStream out：字节输出流，可以传递 FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率 int size：指定缓冲流内部缓冲区的大小，不指定默认。 使用步骤【重要】 ① 创建FileOutputStream对象,构造方法中绑定要输出的目的地 ② 创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 ③ 使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 ④ 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 ⑤ 释放资源(会先调用flush方法刷新数据) public static void main(String[] args) throwsIOException { //1.创建FileOutputStream对象,构造方法中绑定要输出的目的地 FileOutputStream fos = new FileOutputStream(\"E:\\\\a.txt\"); //2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 BufferedOutputStream bos = newBufferedOutputStream(fos); //3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 bos.write(\"我把数据写入到内部缓冲区中\".getBytes()); //4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 bos.flush(); //5.释放资源(会先调用flush方法刷新数据,第4部可以省略) bos.close(); } 二、字节缓冲输入流 java.io.BufferedInputStream extends InputStream BufferedInputStream:字节缓冲输入流 继承自父类的成员方法： int read()从输入流中读取数据的下一个字节。 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 void close() 关闭此输入流并释放与该流关联的所有系统资源。 构造方法： BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 参数： InputStream in：字节输入流，可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率 int size：指定缓冲流内部缓冲区的大小，不指定默认。 使用步骤【重要】： ① 创建FileInputStream对象,构造方法中绑定要读取的数据源 ② 创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 ③ 使用BufferedInputStream对象中的方法read,读取文件 ④ 释放资源 public static void main(String[] args) throwsIOException { //1.创建FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream(\"10_IO\\\\a.txt\"); //2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 BufferedInputStream bis = newBufferedInputStream(fis); //3.使用BufferedInputStream对象中的方法read,读取文件 //int read()从输入流中读取数据的下一个字节。 /*int len = 0;//记录每次读取到的字节*/ while((len = bis.read())!=-1){ System.out.println(len); } //int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 byte[] bytes =new byte[1024];//存储每次读取的数据 int len = 0; //记录每次读取的有效字节个数 while((len = bis.read(bytes))!=-1){ System.out.println(new String(bytes,0,len)); } //4.释放资源 bis.close(); } 三、自写字节缓冲流1、通过自写缓冲流更加理解数据在流中传输的底层原理 2、不止是需要会用，更加需要去充分理解，让每一行代码化繁为简 import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; class MyBufferedOutputStream{ //成员属性 private OutputStream out; //定义缓冲区大小 private static final int DEFAULT_BUFFER_SIZE = 8192; //定义字节数组 private byte[] buf_array; //定义下标index private int index = 0; //构造方法，创建字节数组对象，并将传来的数据长度赋给该对象 private MyBufferedOutputStream(int bufSize){ this.buf_array = new byte[bufSize]; } //构造方法，将传过来的字节输出流进行处理 public MyBufferedOutputStream(OutputStream out){ this(DEFAULT_BUFFER_SIZE); this.out = out; } //构造方法，将传过来的路径字符串进行处理 public MyBufferedOutputStream(String filePath) throws FileNotFoundException { this(DEFAULT_BUFFER_SIZE); this.out = new FileOutputStream(filePath); } //创建write()写入方法，并移动字节数组下标 public void write(int date){ this.buf_array[index++] = (byte) date; } //创建flush()刷新方法，对缓冲区进行刷新，将缓冲区内数据写入进文件 public void flush() throws IOException { this.out.write(this.buf_array,0,index); } // 创建close()方法关闭流，实际上也是调用了flush()方法 // 也是在这一步字节输出流才将数据写入目标文件 public void close(){ try { flush(); // 刷新缓冲区 this.out.close(); } catch (IOException e) { e.printStackTrace(); } } } public class MyBuffereddOutputStreamDemo { // 程序入口，测试自写字节缓冲流 public static void main(String[] args) throws IOException { // 创建输出流对象，如果没有目标文件将会自动创建目标文件 OutputStream outputStream = new FileOutputStream(\"C:\\\\Users\\\\yang\\\\Desktop\\\\yangsir.txt\"); // 使用自写字节缓冲流将输出流进行包装（套管子） MyBufferedOutputStream myBufferedOutputStream = new MyBufferedOutputStream(outputStream); // 测试 myBufferedOutputStream.write(97); myBufferedOutputStream.write(98); // 关闭流，防止内存占用过多 myBufferedOutputStream.close(); } }","categories":[],"tags":[]},{"title":"","slug":"Springboot自动配置","date":"2022-05-15T07:52:29.414Z","updated":"2022-05-15T07:51:57.423Z","comments":true,"path":"2022/05/15/Springboot自动配置/","link":"","permalink":"https://aloctw.github.io/2022/05/15/Springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一、springboot自动配置1.启动器springboot将各种开发功能的环境抽取出来做成了单独的starter(启动器)，开发时只需要在pom.xml中引入启动器，就可以将相关的依赖环境导入进来，所以在使用时做什么功能就引入对应的启动器就可以了。 启动器： spring-boot-starter &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> springboot将依赖的版本用父项目进行管理，在导入依赖时默认不需要指明版本，除非使用的依赖没有在父项目中。 &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.7.0&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> 但是在这里我们并没有看见版本的管理，这里主要是对项目资源过滤以及插件进行管理，在spring-boot-starter-parent点进去可以发现： &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-dependencies&lt;/artifactId> &lt;version>2.7.0&lt;/version> 还有这样一个父依赖，这里才是真正进行版本管理的基地所在。 2.启动类启动类是程序启动的入口，包括了tomcat等服务的启动： @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 看上去简简单单，普普通通，只有几行，但是其中的流程是比较复杂的。 ①、@SpringBootApplication：标注了这个类是springboot的主配置类，并且说明这是一个springboot应用，通过运行它标注的main方法来启动应用，如果没有它程序无法启动。 源码分析：进去之后可以发现在它上面还有注解 //四个元注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //springboot配置类 @SpringBootConfiguration //自动配置 @EnableAutoConfiguration //自动扫描，当前包及其子包， @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { @AliasFor( annotation = EnableAutoConfiguration.class ) ...... } @SpringBootConfiguration：标注当前类为springboot配置类 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented //配置类 @Configuration @Indexed public @interface SpringBootConfiguration { @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true; } 进去之后发现有**@Configuration**，说明这是一个配置类相当于之前的java配置代替xml配置。 @Component public @interface Configuration { @AliasFor( annotation = Component.class ) 继续进去查看，**@Component**一个非常熟悉的注解，说明这个启动类本身也是被spring容器所管理，是其中的一个负责启动的组件。 ②、@EnableAutoConfiguration：在启动类中这个注解，负责开启自动配置，解放双手。 在之前需要我们在xml或者java中配置的相关组件，springboot可以实现自动配置。 继续深入挖掘 //自动配置包 @AutoConfigurationPackage //给容器导入组件 @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class[] exclude() default {}; String[] excludeName() default {}; } @AutoConfigurationPackage：实现自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage { String[] basePackages() default {}; Class[] basePackageClasses() default {}; } @Import({Registrar.class})：在spring容器中导入组件。 Registrar.class：把启动类所在包及其子包的所有组件进行扫描，并导入。 回到上一步： @Import({AutoConfigurationImportSelector.class}) AutoConfigurationImportSelector：自动配置导入选择器 源码追溯： 第一：getCandidateConfigurations()方法，获取候选的配置组件。 并且getSpringFactoriesLoaderFactoryClass() 返回了之前看的启动自动导入配置文件的注解类；EnableAutoConfiguration protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List configurations = new ArrayList(SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader())); ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).forEach(configurations::add); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\"); return configurations; } 第二：可以看到调用了SpringFactoriesLoader.loadFactoryNames()方法，点进去看到调用了loadSpringFactories()方法， public static List loadFactoryNames(Class factoryType, @Nullable ClassLoader classLoader) { ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); } 第三：进去loadSpringFactories()方法，注意三个地方： 1.cache.get(classLoader)：获得classLoader 这里返回EnableAutoConfiguration标注的类本身。 2.classLoader.getResources(FACTORIES_RESOURCE_LOCATION)：这里的FACTORIES_RESOURCE_LOCATION进去后是获取一个资源对象： META-INF&#x2F;spring.factories 。 3.while (urls.hasMoreElements()) {}： 资源遍历并封装成为一个Properties private static Map loadSpringFactories(ClassLoader classLoader) { Map result = cache.get(classLoader); // 获得classLoader 这里返回EnableAutoConfiguration标注的类本身 if (result != null) { return result; } result = new HashMap(); try { Enumeration urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); // 这里的FACTORIES_RESOURCE_LOCATION进去后是获取一个资源对象： *META-INF/spring.factories* 。 // 资源遍历并封装成为一个Properties while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry entry : properties.entrySet()) { String factoryTypeName = ((String) entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue()); for (String factoryImplementationName : factoryImplementationNames) { result.computeIfAbsent(factoryTypeName, key -> new ArrayList()) .add(factoryImplementationName.trim()); } } } 总结：自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。","categories":[],"tags":[]},{"title":"","slug":"动态代理","date":"2022-05-10T07:41:29.231Z","updated":"2022-04-20T02:29:12.029Z","comments":true,"path":"2022/05/10/动态代理/","link":"","permalink":"https://aloctw.github.io/2022/05/10/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"一、 动态代理模式代理： 生成一个代理对象，来代理真实对象，从而控制真实对象的访问 1、静态代理在编译期需要程序员通过程序自定义代理类和创建代理对象 2、动态代理JDK动态（Dynamic）代理 ​ javase提供了动态产生代理对象的API，JDK动态代理需要业务接口，在程序运行过程中动态产生代理对象 1、代理类完成的功能1.目标类中方法的调用2.功能增强2.动态代理在静态代理中目标类很多时候，可以使用动态代理，避免静态代理的缺点。动态代理中目标类即使很多，1) 代理类数量可以很少，2) 当你修改了接口中的方法时，不会影响代理类。**动态代理 **: 在程序执行过程中，使用jdk的反射机制，创建代理类对象，并动态的指定要代理目标类。换句话说:动态代理是一种创建java对象的能力，让你不用创建代理类，就能创建代理类对象。在java中，要想创建对象:1.创建类文件，java文 件编译为class2.使用构造方法，创建类的对象。 动态代理的实现: 1、jdk动态代理(理解):使用java反射包中的类和接口实现动态代理的功能。反射包java. lang. reflect，里面有三个类: InvocationHandler ，Method, Proxy . 2、cglib动态代理(了解) : cglib是第三方的工具库，创建代理对象。cglib的原理是继承，cglib通过继承 目标类，创建它的子类，在子类中重写父类中同名的方法，实现功 能的修改。因为cglib是继承，重写方法，所以要求目标类不能是fina1的，方 法也不能是final的。cglik的要求目标类比较宽松，只要能继承就可以了。cglib在很多的框架中使用,比如mybatis，spring框架 中都有使用。 2、jdk动态代理:1、反射：Method类，表示方法。类中的方法。通 过Method可以执行某个方法。 2、jdk动态代理的实现：反射包java. lang. reflect，里面有三个类:InvocationHandler，Method, Proxy . 3、InvocationHandler接口( 调用处理器) :就- - 个方法invoke ( )invoke():表示代理对象要执行的功能代码。你的代理类要完成的功能就写在invoke()方法中。 代理类完成的功能 1.调用目标方法，执行目标方法的功能2.功能增强，在目标方法调用时，增加功能。 3、方法原型参数:object proxy : jdk创建的代理对象，无需赋值。Method method:目标类中的方法，jdk提供method对 象的object[] args:目标类中方法的参数，jdk提供的。public object invoke (object proxy, Method method, object[] args) 1、InvocationHandler接口表示你的代理要干什么。怎么用:1、创建类实现接口InvocationHandler2、重写invoke ( )方法,把原来静态代理中代理类要完成的功能，写在这InvocationHandler实现类中 3、Method类:表示方法的，确切 的说就是目标类中的方法。作用:通过Method可以执行某个目标类的方法，Method. invoke () ;method. invoke (目标对象，方法的参数) 2、Proxy类核心的对象，创建代理对象。之前创建对象都是new类的构造方法()现在我们是使用Proxy类的方法，代替new的使用。方法:静态方 法newProxyInstance () 1、参数: ClassLoader loader 类加载器，负贲向内存中加载对象的。使用 反射获取对象的ClassLoader 类a，a.getCalss () . getClassLoader()，目 标对象的类加载器 Class&lt;?&gt;[] interfaces: 接口，目标对象实现的接口，也是反射获取的。 InvocationHandler h :我们自己写的，用于目标对象方法增强！ public static object newProxyInstance (ClassLoader loader , Class&lt;?&gt;[] interfaces , InvocationHandler h) 3、案例 1、首先定义目标对象 package com.dyh.dongtai; public interface A { public void changGe(Sting string); } 2、实现目标对象的方法 package com.dyh.dongtai; public class User implements A { @Override public void changGe(String string) { System.out.println(string + \"唱歌！\"); } } 3、目标方法增强代码 package com.dyh.dongtai; public class ZengQiang { public static void qian() { System.out.println(\"业务前\"); } public static void hou() { System.out.println(\"业务后\"); } } 4、创建代理对象 package com.dyh.dongtai; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; //实现InvocationHandler创建代理（可以用内部类实现 如下） /* class B implements InvocationHandler{ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { ZengQiang.qian(); User user = new User(); Object invoke = method.invoke(user); ZengQiang.hou(); return invoke; } } */ // 创建一个代理对象的方法 public class Daili { public User user; public Daili(User user) { this.user = user; } /* getClass 获取字节码文件（） getClassLoder 获取类加载器(字节码文件反射得到) getInterfaces() 动态代理类需要实现的接口，拿到传入对象所有接口的实现类） 动态代理方法在执行时，会调用InvocationHandler实现类里面的invoke方法去执行 */ public Object getProxy() { //内部类实现代理对象的创建 new InvocationHandler() return Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { ZengQiang.qian(); Object invoke = method.invoke(user, args); ZengQiang.hou(); return invoke; } }); } } 5、测试类 package com.dyh.dongtai; public class TextUser { public static void main(String[] args) { //创建实现类 User user = new User(); //创建代理类，传入参数 Daili daili = new Daili(user); //调用getProxy代理方法 A proxy = (A)daili.getProxy(); proxy.changGe(\"李四\"); } } 结果 4、总结：","categories":[],"tags":[]},{"title":"","slug":"Spring","date":"2022-04-17T07:40:14.204Z","updated":"2022-04-18T01:43:43.024Z","comments":true,"path":"2022/04/17/Spring/","link":"","permalink":"https://aloctw.github.io/2022/04/17/Spring/","excerpt":"","text":"一、Spring IOC1、基础概念容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期。 控制反转：IOC (Inversion of Control)，指的是将对象的创建权交给 Spring 去创建。 使用 Spring 之前，对象的创建都是由我们自己在代码中 new 创建。而使用 Spring之后。对象的创建都是由给了 Spring 框架。 IOC (Inversion of Control) 是指在程序开发中，对象实例的创建不再由调用者管理，而是由 Spring 容器创建。Spring 容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此，控制权由程序代码转移到了 Spring 容器中，控制权发生了反转，这就是 Spring 的 IOC 思想。 IOC容器的概念：IOC 容器就是具有依赖注入功能的容器，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IOC 容器进行组装。在 Spring 中 BeanFactory 是 IOC 容器的实际代表者。 Bean的概念：在 Spring 中，被 Spring 容器所管理的对象称之为”Bean”对象。一个 Spring 的 Bean 对象可以是任何形式的 POJO。 依赖注入：DI (Dependency Injection)，是指依赖的对象不需要手动调用 setXX 方法去设置，而是通过配置赋值。 Spring的Xml文件基本结构： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"user\" class=\"com.dyh.pojo.User\">&lt;/bean> &lt;/beans> 2、核心APISpringIOC容器类型：Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext。 BeanFactory 是基础类型的 IoC 容器。它由org.springframework.beans.facytory.BeanFactory 接口定义，并提供了完整的 IoC服务支持。简单来说，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如ApplicationContext、XmlBeanFactory等，其中XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。 public void test_02() { //加载bean.Xml文件 Resource resource = new ClassPathResource(\"bean.xml\"); //将加载完的文件放入XmlBeanFactory容器中 BeanFactory factory = new XmlBeanFactory(resource); User user = (User) factory.getBean(\"user\"); System.out.println(user); ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。 ClassPathXmlApplicationContext：该 类 从 类 路 径 ClassPath 中 寻 找 指 定 的 XML 配 置 文 件 ， 找 到 并 装 载 完 成ApplicationContext 的实例化工作。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean.xml\"); 二、Spring IOC容器的使用1、搭建项目将Spring需要的jar包导入到工程中（目录结构） https://cdn.jsdelivr.net/gh/Aloctw/blog-img/image-20220417202431651.png 2、通过 IOC 容器管理 Bean 对象&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"user\" class=\"com.dyh.pojo.User\">&lt;/bean> &lt;!-- 通过工厂模式来实例化Bean--> &lt;bean id=\"user1\" class=\"com.dyh.pojo.UserFcatory\" factory-method=\"getUser\">&lt;/bean> &lt;!-- 实现FactoryBean接口来实例化Bean--> &lt;bean id=\"user2\" class=\"com.dyh.pojo.UFcatory\">&lt;/bean> &lt;/beans> 3、测试Spring1、测试类package com.dyh.test; import com.dyh.pojo.User; import com.dyh.pojo.UserFcatory; import org.junit.Test; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.xml.XmlBeanFactory; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.core.io.ClassPathResource; import org.springframework.core.io.FileSystemResource; import org.springframework.core.io.Resource; /** * @BelongsProject: Spring_start * @BelongsPackage: com.dyh.test * @Description: * @Author: Lucky * @Date: 2022/4/17 18:58 */ public class TestUser { @Test public void test_01(){ //使用ClassPathXmlApplicationContext实现类去构造Spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); System.out.println(ac); //利用id方法加载bean容器 User user = (User) ac.getBean(\"user\"); System.out.println(user); } /* XmlBeanFactory: 该容器在构造时没有初始化bean，需要调用getBean方法是才初始化bean ClassPathXmlApplicationContext：该容器在创建的时会同时初始化bean */ @Test public void test_02() { //加载bean.Xml文件 Resource resource = new ClassPathResource(\"bean.xml\"); //将加载完的文件放入XmlBeanFactory容器中 BeanFactory factory = new XmlBeanFactory(resource); User user = (User) factory.getBean(\"user\"); System.out.println(user); } //利用工程模式来实例化bean @Test public void test_03() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //通过加载工程类来实现主对象属性 User user1 = (User) ac.getBean(\"user1\"); System.out.println(user1); } //利用FactoryBean接口来实例化Bean @Test public void test_04() { ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); User user2 = (User) ac.getBean(\"user2\"); System.out.println(user2); } } 2、实例化的bean.xml的方法 &lt;bean id=\"user\" class=\"com.dyh.pojo.User\">&lt;/bean> 属性是 Spring 能找到当前 Bean 的一个依赖的编号，遵守 XML 语法的 ID 唯一性约束。class属性就是一个类的全限定名，相当于获取了当前类的类加载（将当前的这个实体类给bean.xml管理） &lt;!-- 通过工厂模式来实例化Bean--> &lt;bean id=\"user1\" class=\"com.dyh.pojo.UserFcatory\" factory-method=\"getUser\">&lt;/bean> 当我们的bean标签中有factory-method属性时，class相当于实例化了当前这个类，然后通过factory-method调用当前这个类的方法（注意一定要是静态方法） &lt;!-- 实现FactoryBean接口来实例化Bean--> &lt;bean id=\"user2\" class=\"com.dyh.pojo.UFcatory\">&lt;/bean> 通过实现接口FactoryBean来实例化bean.xml当我们一个类实现了FactoryBean这个接口会需要实现该接口的三个方法 package com.dyh.pojo; import org.springframework.beans.factory.FactoryBean; /** * @BelongsProject: Spring_start * @BelongsPackage: com.dyh.pojo * @Description: * @Author: Lucky * @Date: 2022/4/17 19:57 */ public class UFcatory implements FactoryBean { @Override //返回有FactoryBean创建的Bean实例，如果isSingleton()返回true,则该实例会放到Spring容器的单实例缓存池中。 public Object getObject() throws Exception { return new User(); } @Override //返回FactoryBean创建Bean的类型。 public Class&lt;?> getObjectType() { return User.class; } @Override //确定由FactoryBean创建Bean的作用域是singleton还是prototype. public boolean isSingleton() { return FactoryBean.super.isSingleton(); } } FactoryBean:FactoryBean是一个Bean，而BeanFactory是我们所说的容器，具有管理Bean的功能，前面我们已经讲述过BeanFactory相关的功能，这里我们不在过多的赘述，他俩的直观区别就是一个是bean，一个是管理bean的容器 (该接口的三个方法内容已在代码注释中解释) 三、在 Spring IOC 容器中获取 Bean 对象的方式1、通过 id 或 name 获取 Bean 对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); System.out.println(ac); //利用id方法加载bean容器 User user = (User) ac.getBean(\"user\"); 2、通过类型获取Bean对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //利用类加载的方式来或去到bean.xml文件的使用 ServiceImpl bean = aa.getBean(ServiceImpl.class); bean.getName(\"阿猪\"); 3、通过id和类加载的方式来实现Bean对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); ServiceImpl service = aa.getBean(\"service\", ServiceImpl.class); service.getName(\"小蒋\"); 四、总结1、 BeanFactory和ApplicationContext的区别​ 这个问题其实问的是 XmlBeanFactory容器与ClassPathXmlApplicationContext（或者FileSystemXmlApplicationContext）容器的区别 XmlBeanFactory容器在初始化时不会创建bean，而是在getBean()调用方法时才会去创建，其他两个在构造容器时就将bena.xml初始化了 2、BeanFactory和FactoryBean区别？BeanFactory是工厂类，提供了获取和检索Bean的接口。它代表着Spring的IoC容器，负责Bean实例化以及管理Bean之间的依赖关系。作为Spring框架中最核心的模块，它提供容器的基本规范。 FactoryBean是一个bean，可以作为其他bean的工厂。FactoryBean像其他bean一样在注入到IoC容器中，但是当从IoC容器中获取FactoryBean的时候，实际返回的FactoryBean#getObject()方法返回的对象。如果想获取FactoryBean本身，则需要在bean的名称添加前缀&amp;来获取FactoryBean对象本身（applicationContext.getBean(“&amp;” + beanName)）。","categories":[],"tags":[]},{"title":"","slug":"Spring AOP","date":"2022-04-17T07:40:14.202Z","updated":"2022-05-04T11:13:48.061Z","comments":true,"path":"2022/04/17/Spring AOP/","link":"","permalink":"https://aloctw.github.io/2022/04/17/Spring%20AOP/","excerpt":"","text":"一、Spring AOP1、 什么是 AOP描述：Aop也叫面向切面编程，他同OOP面向对象编程一样，只是一种编程思想。具体的作用就是为了对OOP互补，OOP的编程思想是自上而下，然而有的时候我们需要从中间加入某一些特殊的方法。因此Aop正好就帮我们实现了这个功能。 用途：aop主要用在日志输出，在不改变原来代码的基础之上，我们可以加入自己的一些代码，如日志功能、缓存功能、安全校验功能等 2、实现aop的主要是两种（1）jdk动态代理——默认就是jdk代理，jdk代理主要是代理接口 （2）CGLIB动态代理——需要我们设置，CGLIB主要是代理类，如果这个类没有实现接口就可以使用CGLIB代理，如果有接口只能使用jdk动态代理。 实现 BeanpostProcessor bean后处理器 定义两个属性 private 代理对象 private 拦截器 Spring事物管理 简述 在声明式的事务处理中，要配置一个切面，其中就用到了propagation，表示打算对这些方法怎么使用事务，是用还是不用，其中propagation有七种配置，REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。默认是REQUIRED。 Spring中七种Propagation类的事务属性详解： REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。 注意事项 这些配置将影响数据存储，必须根据情况选择。","categories":[],"tags":[]},{"title":"","slug":"Mybatis入门","date":"2022-04-06T07:38:06.188Z","updated":"2022-04-13T02:19:25.822Z","comments":true,"path":"2022/04/06/Mybatis入门/","link":"","permalink":"https://aloctw.github.io/2022/04/06/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、关于MyBatis 持久层可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏（大部分的重要数据都会有相关的备份机制)，在断电或者其他情况下，重新开启系统仍然可以读取这些数据。 Mybatis 是一个优秀的持久层框架，它对 jdbc 的操作数据库的过程进行封装，使得开发者只需要专注 于 SQL 语句本身，而不用去关心注册驱动，创建 connection 等 Mybatis 通过 xml 文件配置或者注解的方式将要执行的各种 statement 配置起来，并通过 java 对象 和statement中的sql进行映射成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射成java 对象并返回。 不屏蔽 SQL 意味着可以更为精确地定位 SQL 语句，可以对其进行优化和改造， 这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 并且它提供强大、灵活的映射机制 ，方便 Java 开发者使用 。提供动态 SQL 的功能，允许 我们根据不同条件组装 SQL ，这个功能远比其他工具或者 Java 编码的可读性和可维 护性高得多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要 求。 在MyBatis 中，提供了使用 Mapper 的接口编程，只要 个接口和 XML 就能创 建映射器，进一步简化我们的工作，使得很多框架 API MyBatis 中消失，开发者 能更集中于业务逻辑 。 二、MyBatis的核心组件 MyBatis的核心组件分为四个部分： 1.SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成SqlSessionFactory采用的是分布构建的Builder模式。 2.SqlSessionFactory (工厂接口)：依靠它来生成 SqlSession，使用的是工厂模式。 3.SqlSession（会话):一个既可以发送SQL执行返回结果，也可以获取 Mapper 的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis提供的SQL Mapper 接口编程技术，它能提高代码的可读性和可维护性。 4.SQL Mapper（映射器):MyBatis 新设计存在的组件，它由一个Java 接口和 XML文件（或注解）构成，需要给出对应的SQL 和映射规则。它负责发送SQL去执行,并返回结果。 三、使用XML构建SQLSessionFactory 在MyBatis中的XML文件分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境；另一类是映射文件，它可以配置映射关系、SQL、参数等信息。 ​ 配置文件名可自定义 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!-- 引入xml的约束文件：约束当前xml文档中能使用什么标签 xml：可以扩展标记语言，描述信息的方式是标签 xml的约束文件分两种 dtd: Mybatis使用的就是这种 schema：spring使用的就是这种--> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;typeAliases> &lt;!-- 指定包下的所有类都有别名：类的全限定类名去掉包名，剩下的部分不区分大小写 --> &lt;package name=\"com.dyh.pojo\"/> &lt;/typeAliases> &lt;!-- enviroments标签配置多种数据库环境 --> &lt;environments default=\"dev\"> &lt;environment id=\"dev\"> &lt;!-- transactionManager 事务管理器 --> &lt;!-- JDBC – 这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。 MANAGED – 这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期 （比如 Spring 或 JEE 应用服务器的上下文）。默认情况下它会关闭连接。 --> &lt;transactionManager type=\"JDBC\">&lt;/transactionManager> &lt;!-- 连接数据库 --> &lt;!-- POOLED 连接池（数据源），其实就是一个容器（集合），存放数据库连接的容器 --> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1/d_movie\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"123456\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--将映射文件加载到mybatis的配置文件中 mappers会扫描指定的包，Mybatis会为指定包下所有映射器 --> &lt;mappers> &lt;package name=\"com.dyh.dao\"/> &lt;/mappers> &lt;/configuration> 四、SqlSession​ 在MyBatis 中, SqISession是其核心接口。在MyBatis中有两个实现类, DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager在多线程环境下使用。SqlSession的作用类似于一个 JDBC 中的 Connection对象，代表着一个连接资源的启用。具体而言，它的作用有3个：获取Mapper接口，发送SQL给数据库，控制数据库事务。 有了SqlSessionFactory创建SqlSession是非常简单的，注意SqlSession只是一个门面接口，真正执行业务语句的是底层的Executor！ ​ 我这里编写了一个工具类用来加载配置文件 package com.dyh.uilt; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; /** * @BelongsProject: Mybatis_02 * @BelongsPackage: com.dyh.pojo * @Description: * @Author: Lucky * @Date: 2022/4/11 19:42 */ public class Uilts { private Uilts() { } private static SqlSessionFactory factory; public static synchronized SqlSessionFactory getSqlSessionFactory() { if(factory == null) { try { InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\"); factory = new SqlSessionFactoryBuilder().build(is); } catch (IOException e) { e.printStackTrace(); } } return factory; } public static SqlSession getSqlSession() { if(factory == null) { getSqlSessionFactory(); } return factory.openSession(); } } 五、映射器 映射器是MyBatis中最重要也是最复杂的组件，它由一个接口和一个对应的XML文件组成。 它可以配置以下内容： 描述映射规则 提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息 配置缓存 提供动态SQL 定义一个映射器接口： package com.dyh.dao; import com.dyh.pojo.User; /** * @BelongsProject: Mybatis_02 * @BelongsPackage: com.dyh.dao * @Description: * @Author: Lucky * @Date: 2022/4/11 19:43 */ public interface UserMapper { User getById(int id); } 配置映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.dyh.dao.UserMapper\"> &lt;!-- 使用resultMap标签来手动映射：定义字段和属性的映射规则 id属性：一套映射规则的标识符,名称任意 type属性： 封装的对象类型（可以使用全限定类名或别名） --> &lt;resultMap id=\"UserMap\" type=\"User\"> &lt;id column=\"m_id\" property=\"id\">&lt;/id> &lt;result column=\"m_name\" property=\"name\">&lt;/result> &lt;result column=\"m_picse\" property=\"picse\">&lt;/result> &lt;result column=\"m_author\" property=\"author\">&lt;/result> &lt;result column=\"m_date\" property=\"sqlDate\">&lt;/result> &lt;/resultMap> &lt;!--更具id查询数据--> &lt;select id=\"getById\" resultMap=\"UserMap\"> select * from movie where m_id = #{id} &lt;/select> &lt;/mapper> 在这里面我使用了是自定义映射（resultMap），将我们从数据库获取的数据封装到我们自定义的属性中去（进行手动映射）。","categories":[],"tags":[]},{"title":"jdbc","slug":"jdbc","date":"2022-03-21T12:26:24.000Z","updated":"2022-03-22T06:25:42.674Z","comments":true,"path":"2022/03/21/jdbc/","link":"","permalink":"https://aloctw.github.io/2022/03/21/jdbc/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"Aloctw"},{"title":"","slug":"线程与进程","date":"2022-03-14T03:39:44.625Z","updated":"2022-03-01T08:06:26.790Z","comments":true,"path":"2022/03/14/线程与进程/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"1、线程与线程1.1 进程 进程：正在运行的程序 是系统进行分配的调用和独立单位 每一个进程都有自己的内存空间和系统资源 1.2 线程 线程：是进程中的单个控制流程，是一条执行路径 单线程：一个进程如果只有一条执行路径，则称之为单线程 多线程：一个进行如果有多个执行路径，则成为多线程 2、多线程的实现方式2.1 创建线程对象定义一个类来继承Thread类，并且在定义类中重写Thread的run()；方法，然后在创建定义类对象，最后启动线程 例： package com.dyh.thread; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /* 定义一个类来继承Thread类， 并且在定义类中重写Thread的run();方法， 然后在创建定义类对象，最后启动线程 */ class ThreadDome extends Thread { @Override public void run() { for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日的车次有以下：\" + getName() + \": G\" + i); } } } public class ThreadDome01 { public static void main(String[] args) { //创建线程对象（开辟线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); //创建main主线程（主线程优先级高于子线程） //Thread.currentThread().getName()，打印线程名称 for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } } } 2.2 Runnable接口自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中run()方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 需要在new一个线程（Thread）对象出来，进行调用这个任务类（Thread(Runnable target, String name)） 例： package com.dyh.thread; /* 自定义一个类实现Runnable接口，这个类是一个任务类， 这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象， 如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 */ //首先自定义一个任务类 class Myrunnble implements Runnable { //重写Thread的Run()方法 //Thread.currentThread().getName()打印出线程的名称 @Override public void run() { for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i); } } } public class ThreadRunnable { public static void main(String[] args) { //创建任务对象 Myrunnble mr = new Myrunnble(); //创建一个线程 //Thread(Runnable target, String name) //指的就是Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target //分配一个新的 Thread对象。 Thread thread = new Thread(mr, \"高铁\"); thread.start(); //创建主线程（主线程优先级高于子线程） for (int j = 0; j &lt; 100; j++) { System.out.println(Thread.currentThread().getName() + \" -\" + j); } } } 2.3Callable接口package com.dyh.thread; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* 1、创建一个Callable接口实现类，实现call()方法，该call()方法作为执行体 且没有返回值 2、使用FutureTast类来包装Callable对象，该FutureTast对象封装了 该Callable对象的call()方法的返回值 3、使用FutureTast对象作为Thread对象的target创建并启动线程。 //Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target 4、调用FutureTast对象的get()方法来获取子线程执行结束后的返回值 */ // 实现了Callable接口的类，也是一个任务类 class MyCallable implements Callable&lt;Integer> { @Override public Integer call() throws Exception { //书写方法体 for (int i = 0; i &lt;= 100; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } //返回-1则表明线程结束 return -1; } } public class ThreadCallable { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建任务对象 MyCallable mc = new MyCallable(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 //使用FutureTast来包装Callable对象 FutureTask&lt;Integer> task = new FutureTask&lt;>(mc); //创建一个线程对象 //因为FutureTask对象这个对象实现了RunnableFuture接口 Thread thread = new Thread(task, \"高铁\"); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + \"-\" + i); } //通过get()方法来获取Callable任务方法的返回值、 //isDone判断该Callable任务是否完成 if (task.isDone()) { Integer integer = task.get(); System.out.println(integer); } } } 3、小结3.1为什么要重写run();方法？ run();方法是用来封装被线程执行的代码 class ThreadDome extends Thread { @Override public void run() { //格式化时间（设置控制台输出的时间格式） SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); //获取当前时间，sdf.format(d)格式化时间 Date d = new Date(); for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日日期为：\" + sdf.format(d) + \" 今日的车次有以下：\" + getName() + \": G\" + i); } } } 3.2 run();方法和start();方法的区别？ run()：方法是线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程，然后由JVM虚拟机来调用此线程的run()方法 3.3 设置和获取线程名称 void setName（String name）,将此线程的名称改为等于参数name（setName给线程赋值） //String getName()：返回此线程名称 public class ThreadDome01 { public static void main(String[] args) { //实例化ThreadDome（开辟两个线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); （String getName()：返回此线程名称）调用Thread类中的有参构造，直接在实例化的时候就进行赋值 //调用Thread的有参构造方法 class ThreadDome extends Thread { private String name; //无参构造 public ThreadDome() { } //有参构造（调用父类的有参构造） public ThreadDome(String name) { super(name); } //run（）未重新 public class ThreadDome01 { public static void main(String[] args) { //String getName(); ThreadDome td = new ThreadDome(\"复兴号\"); ThreadDome td1 = new ThreadDome(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); } ​ 通过构造方法也可以设置线程名称 //Thread.currentThread().getName() for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i);} 4、线程的生命周期（未完。。。）","categories":[],"tags":[]},{"title":"","slug":"多线程","date":"2022-03-14T03:39:44.610Z","updated":"2022-03-01T08:12:09.627Z","comments":true,"path":"2022/03/14/多线程/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"1、线程与线程1.1 进程 进程：正在运行的程序 是系统进行分配的调用和独立单位 每一个进程都有自己的内存空间和系统资源 1.2 线程 线程：是进程中的单个控制流程，是一条执行路径 单线程：一个进程如果只有一条执行路径，则称之为单线程 多线程：一个进行如果有多个执行路径，则成为多线程 2、多线程的实现方式2.1 创建线程对象定义一个类来继承Thread类，并且在定义类中重写Thread的run()；方法，然后在创建定义类对象，最后启动线程 例： package com.dyh.thread; import java.text.SimpleDateFormat; import java.util.Date; import java.util.logging.SimpleFormatter; /* 定义一个类来继承Thread类， 并且在定义类中重写Thread的run();方法， 然后在创建定义类对象，最后启动线程 */ class ThreadDome extends Thread { @Override public void run() { for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日的车次有以下：\" + getName() + \": G\" + i); } } } public class ThreadDome01 { public static void main(String[] args) { //创建线程对象（开辟线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); //创建main主线程（主线程优先级高于子线程） //Thread.currentThread().getName()，打印线程名称 for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } } } 2.2 Runnable接口自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中run()方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 需要在new一个线程（Thread）对象出来，进行调用这个任务类（Thread(Runnable target, String name)） 例： package com.dyh.thread; /* 自定义一个类实现Runnable接口，这个类是一个任务类， 这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象， 如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象 */ //首先自定义一个任务类 class Myrunnble implements Runnable { //重写Thread的Run()方法 //Thread.currentThread().getName()打印出线程的名称 @Override public void run() { for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i); } } } public class ThreadRunnable { public static void main(String[] args) { //创建任务对象 Myrunnble mr = new Myrunnble(); //创建一个线程 //Thread(Runnable target, String name) //指的就是Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target //分配一个新的 Thread对象。 Thread thread = new Thread(mr, \"高铁\"); thread.start(); //创建主线程（主线程优先级高于子线程） for (int j = 0; j &lt; 100; j++) { System.out.println(Thread.currentThread().getName() + \" -\" + j); } } } 2.3Callable接口package com.dyh.thread; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; /* 1、创建一个Callable接口实现类，实现call()方法，该call()方法作为执行体 且没有返回值 2、使用FutureTast类来包装Callable对象，该FutureTast对象封装了 该Callable对象的call()方法的返回值 3、使用FutureTast对象作为Thread对象的target创建并启动线程。 //Thread要执行的你的业务逻辑的封装，即实现Runnable重写run方法的类，线程启动后， 会异步去执行这个类的run方法，这个类就是target 4、调用FutureTast对象的get()方法来获取子线程执行结束后的返回值 */ // 实现了Callable接口的类，也是一个任务类 class MyCallable implements Callable&lt;Integer> { @Override public Integer call() throws Exception { //书写方法体 for (int i = 0; i &lt;= 100; i++) { System.out.println(Thread.currentThread().getName() + \" \" + i); } //返回-1则表明线程结束 return -1; } } public class ThreadCallable { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建任务对象 MyCallable mc = new MyCallable(); // 创建FutureTask对象这个对象实现了RunnableFuture接口 // RunnableFuture多继承了Runnable接口和Future接口 //使用FutureTast来包装Callable对象 FutureTask&lt;Integer> task = new FutureTask&lt;>(mc); //创建一个线程对象 //因为FutureTask对象这个对象实现了RunnableFuture接口 Thread thread = new Thread(task, \"高铁\"); //启动线程 thread.start(); //主线程 for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + \"-\" + i); } //通过get()方法来获取Callable任务方法的返回值、 //isDone判断该Callable任务是否完成 if (task.isDone()) { Integer integer = task.get(); System.out.println(integer); } } } 3、小结3.1为什么要重写run();方法？ run();方法是用来封装被线程执行的代码 class ThreadDome extends Thread { @Override public void run() { //格式化时间（设置控制台输出的时间格式） SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); //获取当前时间，sdf.format(d)格式化时间 Date d = new Date(); for (int i = 52; i &lt;63 ; i++) { //getName()调用了Thread的无参构造方法（子类继承了父类的构造方法） System.out.println(\"今日日期为：\" + sdf.format(d) + \" 今日的车次有以下：\" + getName() + \": G\" + i); } } } 3.2 run();方法和start();方法的区别？ run()：方法是线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程，然后由JVM虚拟机来调用此线程的run()方法 3.3 设置和获取线程名称 void setName（String name）,将此线程的名称改为等于参数name（setName给线程赋值） //String getName()：返回此线程名称 public class ThreadDome01 { public static void main(String[] args) { //实例化ThreadDome（开辟两个线程） ThreadDome td = new ThreadDome(); ThreadDome td1 = new ThreadDome(); //调用Thread的带参构造方法，使用setName方法改变线程的名称 td.setName(\"复兴号\"); td1.setName(\"和谐号\"); （String getName()：返回此线程名称）调用Thread类中的有参构造，直接在实例化的时候就进行赋值 //调用Thread的有参构造方法 class ThreadDome extends Thread { private String name; //无参构造 public ThreadDome() { } //有参构造（调用父类的有参构造） public ThreadDome(String name) { super(name); } //run（）方法未重写 public class ThreadDome01 { public static void main(String[] args) { //String getName(); ThreadDome td = new ThreadDome(\"复兴号\"); ThreadDome td1 = new ThreadDome(\"和谐号\"); //调用start()方法启动线程,JVM虚拟机会自动调用run()方法 td.start(); td1.start(); } ​ 通过构造方法也可以设置线程名称 //Thread.currentThread().getName() for (int i = 0; i &lt; 100 ; i++) { System.out.println(Thread.currentThread().getName() + \"--\" + i);} 4、线程的生命周期（未完。。。）","categories":[],"tags":[]},{"title":"","slug":"多线程生命周期","date":"2022-03-14T03:39:44.610Z","updated":"2022-03-02T01:37:39.041Z","comments":true,"path":"2022/03/14/多线程生命周期/","link":"","permalink":"https://aloctw.github.io/2022/03/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"1.生命周期1.1 多线程生命周期的六种状态（官方文档） 线程的状态我们可以在api文档中搜索Thread.State便可以得到下列的六种状态。 线程状态 描述 官方解释（api） 新建状态（NEW） 创建线程对象 线程尚未开始在这个国家 可运行状态（RUNNABLE） start()方法 正在java虚拟机中执行的线程 阻塞状态（BLOCKED） 无法获得锁对象 受阻塞并等待某个监视器锁的线程 无限等待状态（WAITING） wait()，join()方法 处于这种状态的线程被无限期地等待另一个线程来执行特定的动作。 超时等待状态（TIMEND_WAITING） sleep()方法 无限期的等待另一个线程来执行某一特定操作的线程 终止状态（TERMINATED） 全部代码运行完毕 已退出的线程处于这种状态 （附图）网上copy来的 Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态，线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换 这些状态是不反映任何操作系统线程状态的虚拟机状态 1.2 生命周期六种状态源码public enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul> * &lt;li>{@link Object#wait() Object.wait} with no timeout&lt;/li> * &lt;li>{@link #join() Thread.join} with no timeout&lt;/li> * &lt;li>{@link LockSupport#park() LockSupport.park}&lt;/li> * &lt;/ul> * * &lt;p>A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt>Object.wait()&lt;/tt> * on an object is waiting for another thread to call * &lt;tt>Object.notify()&lt;/tt> or &lt;tt>Object.notifyAll()&lt;/tt> on * that object. A thread that has called &lt;tt>Thread.join()&lt;/tt> * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul> * &lt;li>{@link #sleep Thread.sleep}&lt;/li> * &lt;li>{@link Object#wait(long) Object.wait} with timeout&lt;/li> * &lt;li>{@link #join(long) Thread.join} with timeout&lt;/li> * &lt;li>{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li> * &lt;li>{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li> * &lt;/ul> */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; }","categories":[],"tags":[]}],"categories":[{"name":"redis","slug":"redis","permalink":"https://aloctw.github.io/categories/redis/"},{"name":"技术","slug":"技术","permalink":"https://aloctw.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]}